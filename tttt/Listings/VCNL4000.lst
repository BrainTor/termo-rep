C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE VCNL4000
OBJECT MODULE PLACED IN .\obj\VCNL4000.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE VCNL4000.c LARGE OBJECTADVANCED BROWSE INCDIR(..\T5L51) DEBUG PRINT(.\Listi
                    -ngs\VCNL4000.lst) TABS(2) OBJECT(.\obj\VCNL4000.obj)

line level    source

   1          #include "vcnl4000.h" 
   2          
   3          #define I2C_SCL_SETOUT      {P1MDOUT|=0x80;} 
   4          #define I2C_SDA_SETOUT       {P1MDOUT|= 0x20;}  
   5          #define I2C_SDA_SETIN       {P1MDOUT&= ~0x20;}  
   6          #define SCL_H         I2C_SCLDATA_PORT = 1;
   7          #define SCL_L         I2C_SCLDATA_PORT = 0;
   8             
   9          #define SDA_H         {P1MDOUT|= 0x20;I2C_SDADATA_PORT = 1;}
  10          #define SDA_L         {P1MDOUT|= 0x20;I2C_SDADATA_PORT = 0;}
  11          
  12          #define SDA_read      (I2C_SDADATA_PORT)
  13          
  14          u16 VCNL4200_ALS_Result = 0;
  15          u16 VCNL4200_PROX_Result = 0;
  16          u8 VCNL4200_Register[12] ={0};
  17          
  18          //|---------------------------------------------------|
  19          //|Function   :I2C_Init
  20          //|Description  :initialize I2C GPIO,SCL and SDA
  21          //|Input    :None
  22          //|Output   :None
  23          //|Return   :None
  24          //|---------------------------------------------------|
  25          void I2C_Initial(void)
  26          {
  27   1        I2C_SCL_SETOUT;    
  28   1        I2C_SDA_SETOUT;   
  29   1      }
  30          
  31          /*******************************************************************************
  32          * Function Name  : I2C_delay
  33          * Description    : Simulation IIC Timing series delay
  34          * Input          : None
  35          * Output         : None
  36          * Return         : None
  37          ********************************************************************************/
  38          void I2C_delay(void)
  39          { 
  40   1        u8 i=30; //ÕâÀï¿ÉÒÔÓÅ»¯ËÙ¶È £¬¾­²âÊÔ×îµÍµ½5»¹ÄÜÐ´Èë
  41   1        while(i) 
  42   1        { 
  43   2        i--; 
  44   2        } 
  45   1      //  delay_us(30);
  46   1      }
  47          
  48          void delay5ms(void)
  49          { 
  50   1        u16 i=5000;  
  51   1        while(i) 
  52   1        { 
  53   2        i--; 
  54   2        }
C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 2   

  55   1      //  delay_ms(5);
  56   1      }
  57          /*******************************************************************************
  58          * Function Name  : I2C_Start
  59          * Description    : Master Start Simulation IIC Communication
  60          * Input          : None
  61          * Output         : None
  62          * Return         : Wheather  Start
  63          ****************************************************************************** */
  64          u8 I2C_Start(void)
  65          {
  66   1        I2C_SDA_SETOUT;
  67   1        SDA_H;
  68   1        SCL_H;
  69   1        I2C_delay();
  70   1        if(!SDA_read)return 0;  //SDAÏßÎªµÍµçÆ½Ôò×ÜÏßÃ¦,ÍË³ö
  71   1        SDA_L;
  72   1        I2C_delay();
  73   1        if(SDA_read) return 0;  //SDAÏßÎª¸ßµçÆ½Ôò×ÜÏß³ö´í,ÍË³ö
  74   1        SDA_L;
  75   1        I2C_delay();
  76   1        SCL_L;
  77   1        return 1;
  78   1      }
  79          /*******************************************************************************
  80          * Function Name  : I2C_Stop
  81          * Description    : Master Stop Simulation IIC Communication
  82          * Input          : None
  83          * Output         : None
  84          * Return         : None
  85          ****************************************************************************** */
  86          void I2C_Stop(void)
  87          {
  88   1        I2C_SDA_SETOUT;
  89   1        SCL_L;
  90   1        I2C_delay();
  91   1        SDA_L;
  92   1        I2C_delay();
  93   1        SCL_H;
  94   1        I2C_delay();
  95   1        SDA_H;
  96   1        I2C_delay();
  97   1      } 
  98          /*******************************************************************************
  99          * Function Name  : I2C_Ack
 100          * Description    : Master Send Acknowledge I2C
 101          * Input          : None
 102          * Output         : None
 103          * Return         : None
 104          ****************************************************************************** */
 105          void I2C_Ack(void)
 106          { 
 107   1        SCL_L;
 108   1        I2C_delay();
 109   1        SDA_L;
 110   1        I2C_delay();
 111   1        SCL_H;
 112   1        I2C_delay();
 113   1        SCL_L;
 114   1        I2C_delay();
 115   1      }   
 116          
C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 3   

 117          /*******************************************************************************
 118          * Function Name  : I2C_NoAck
 119          * Description    : Master Send No Acknowledge I2C
 120          * Input          : None
 121          * Output         : None
 122          * Return         : None
 123          ****************************************************************************** */
 124          void I2C_NoAck(void)
 125          { 
 126   1        SCL_L;
 127   1        I2C_delay();
 128   1        SDA_H;
 129   1        I2C_delay();
 130   1        SCL_H;
 131   1        I2C_delay();
 132   1        SCL_L;
 133   1        I2C_delay();
 134   1      } 
 135          
 136          /*******************************************************************************
 137          * Function Name  : I2C_WaitAck
 138          * Description    : Master Reserive Slave Acknowledge I2C
 139          * Input          : None
 140          * Output         : None
 141          * Return         : Wheather  Reserive Slave Acknowledge I2C
 142          ****************************************************************************** */
 143          u8 I2C_WaitAck(void)   //·µ»ØÎª:=1ÓÐACK,=0ÎÞACK
 144          {
 145   1        I2C_SDA_SETIN;
 146   1        SCL_L;
 147   1        I2C_delay();
 148   1        SDA_H;      
 149   1        I2C_delay();
 150   1        SCL_H;
 151   1        I2C_delay();
 152   1        if(SDA_read)
 153   1        {
 154   2            SCL_L;
 155   2            I2C_SDA_SETOUT;
 156   2            I2C_delay();
 157   2            return 0;
 158   2        }
 159   1        SCL_L;
 160   1        I2C_SDA_SETOUT;
 161   1        I2C_delay();
 162   1        return 1;
 163   1      }
 164          
 165          /*******************************************************************************
 166          * Function Name  : I2C_SendByte
 167          * Description    : Master Send a Byte to Slave
 168          * Input          : Will Send Date
 169          * Output         : None
 170          * Return         : None
 171          ****************************************************************************** */
 172          void I2C_SendByte( u8 SendByte) //Êý¾Ý´Ó¸ßÎ»µ½µÍÎ»//
 173          {
 174   1        u8 i=8;
 175   1        while(i--)
 176   1        {
 177   2          SCL_L;
 178   2          I2C_delay();
C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 4   

 179   2          if(SendByte&0x80) {SDA_H;}  
 180   2          else  {SDA_L;}   
 181   2          SendByte<<=1;
 182   2          I2C_delay();
 183   2          SCL_H;
 184   2          I2C_delay();
 185   2        }
 186   1        SCL_L;
 187   1      }  
 188          
 189          /*******************************************************************************
 190          * Function Name  : I2C_ReadByte
 191          * Description    : Master Reserive a Byte From Slave
 192          * Input          : None
 193          * Output         : None
 194          * Return         : Date From Slave 
 195          ****************************************************************************** */
 196          u8 I2C_ReadByte(void)  //Êý¾Ý´Ó¸ßÎ»µ½µÍÎ»//
 197          { 
 198   1          u8 i=8;
 199   1          u8 ReceiveByte=0;
 200   1          I2C_SDA_SETIN;
 201   1        while(i--)
 202   1        {
 203   2          ReceiveByte<<=1;      
 204   2          SCL_L;
 205   2          I2C_delay();
 206   2          SCL_H;
 207   2          I2C_delay();  
 208   2          if(SDA_read)
 209   2          {
 210   3            ReceiveByte|=0x01;
 211   3          }
 212   2        }
 213   1          SCL_L;
 214   1          return ReceiveByte;
 215   1      }
 216          
 217          //|---------------------------------------------------|
 218          //|Function   :I2C_Write
 219          //|Description  :Write data to SlaveDeive's register
 220          //|Input    :
 221          //|         SlaveAddress:Slave Device's Address
 222          //|         REG_Address :Slave Device's Register Address
 223          //|         REG_data  :Data to be wrote into register
 224          //|Output   :None
 225          //|Return   :u8 data of slave device's register
 226          //|---------------------------------------------------|
 227          u8 I2C_Write(u8 SlaveAddress, u8 REG_Address, u8 REG_data)         //void
 228          {
 229   1        if(!I2C_Start())return 0;
 230   1        I2C_SendByte(SlaveAddress);   //·¢ËÍÉè±¸µØÖ·+Ð´ÐÅºÅ//I2C_SendByte(((REG_Address & 0x0700) >>7) | SlaveAdd
             -ress & 0xFFFE);//ÉèÖÃ¸ßÆðÊ¼µØÖ·+Æ÷¼þµØÖ· 
 231   1        I2C_WaitAck();  
 232   1        I2C_SendByte(REG_Address);    //ÉèÖÃµÍÆðÊ¼µØÖ·      
 233   1        I2C_WaitAck();  
 234   1        I2C_SendByte(REG_data);
 235   1        I2C_WaitAck();   
 236   1        I2C_Stop(); 
 237   1        delay5ms();
 238   1        return 1;
 239   1      }
C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 5   

 240          
 241          //|---------------------------------------------------------------------|
 242          //|Function   :I2C_Read
 243          //|Description  :Read I2C_Device's Register
 244          //|Input    :
 245          //|         SlaveAddress:Slave Device's Address
 246          //|         REG_Address :Slave Device's Register Address
 247          //|Output   :None
 248          //|Return   :u8  value of Register
 249          //|---------------------------------------------------------------------|
 250          u8 I2C_Read(u8 SlaveAddress,u8 REG_Address)
 251          {   
 252   1        u8 REG_data;      
 253   1        I2C_Start();
 254   1        I2C_SendByte(SlaveAddress); //I2C_SendByte(((REG_Address & 0x0700) >>7) | REG_Address & 0xFFFE);//ÉèÖÃ¸ßÆ
             -ðÊ¼µØÖ·+Æ÷¼þµØÖ· 
 255   1        I2C_WaitAck();
 256   1        I2C_SendByte((u8) REG_Address);   //ÉèÖÃµÍÆðÊ¼µØÖ·      
 257   1        I2C_WaitAck();
 258   1        I2C_Start();
 259   1        I2C_SendByte(SlaveAddress+1);
 260   1        I2C_WaitAck();
 261   1        
 262   1        REG_data= I2C_ReadByte();
 263   1        I2C_NoAck();
 264   1        I2C_Stop();
 265   1        return REG_data;
 266   1      }
 267          
 268          
 269          void I2C_ReadRegister(u8 startaddr, u8 *regbuf, u8 num)
 270          {
 271   1        u8 i=0;
 272   1        for(i=0;i<num;i++,regbuf++,startaddr++)
 273   1        {
 274   2          *regbuf = I2C_Read(0x26,startaddr);
 275   2        }
 276   1      }
 277          
 278          void VCNL4200_ReadOneWords(u8 ReadAddr,u8* databuf)
 279          {         
 280   1      //  u16 temp;                                            
 281   1          I2C_Start();
 282   1        I2C_SendByte(VCNL4200_Write);   //·¢ËÍÐ´ÃüÁî
 283   1        I2C_WaitAck();      
 284   1        I2C_SendByte(ReadAddr);       //·¢ËÍÐèÒªÐ´µÄÄ¿µÄµØÖ·
 285   1        I2C_WaitAck();
 286   1      //  I2C_Stop();           //²úÉúÒ»¸öÍ£Ö¹Ìõ¼þ
 287   1      
 288   1        I2C_Start();                       
 289   1        I2C_SendByte(VCNL4200_Read);    //Ð´Èë Ð´ÃüÁî,½øÈë½ÓÊÕÄ£Ê½
 290   1        I2C_WaitAck();          
 291   1          databuf[0]=I2C_ReadByte();        //½ÓÊÕÊý¾Ý
 292   1        I2C_Ack();          
 293   1          databuf[1]=I2C_ReadByte();        //½ÓÊÕÊý¾Ý
 294   1          I2C_Stop();           //Í£Ö¹
 295   1              
 296   1      //  return temp;          //·µ»Ø¶Á³öµÄÊý¾Ý
 297   1      }
 298          
 299          void VCNL4200_WriteOneWords(u8 WriteAddr,u8 *DataToWrite)
 300          {   
C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 6   

 301   1      //  u8 dataW[2] = {0};  
 302   1      //  dataW = DataToWrite;
 303   1          I2C_Start();          //¿ªÊ¼
 304   1        I2C_SendByte(VCNL4200_Write); //·¢ËÍÐ´ÃüÁî
 305   1        I2C_WaitAck();          //µÈ´ýVCNL·µ»ØÒ»¸öACK
 306   1          I2C_SendByte(WriteAddr);      //·¢ËÍÐèÒªÐ´µÄÄ¿µÄµØÖ·
 307   1        I2C_WaitAck();          //µÈ´ýVCNL·µ»ØÒ»¸öACK
 308   1        I2C_SendByte(DataToWrite[0]);      //·¢ËÍÒªÐ´ÈëµÄµØÖ·                
 309   1        I2C_WaitAck();            //µÈ´ýVCNL·µ»ØÒ»¸öACK  
 310   1        I2C_SendByte(DataToWrite[1]);      //·¢ËÍÒªÐ´ÈëµÄµØÖ·                
 311   1        I2C_WaitAck();            //µÈ´ýVCNL·µ»ØÒ»¸öACK  
 312   1          I2C_Stop();           //²úÉúÒ»¸öÍ£Ö¹Ìõ¼þ 
 313   1        delay_ms(10);  
 314   1      }
 315          
 316          //----------³õÊ¼»¯----------
 317          void VCNL4200_Init(void)
 318          {
 319   1        u8  conf_data[2];
 320   1        
 321   1        I2C_Initial();                    //³õÊ¼»¯I2CÒý½Å
 322   1        conf_data[0] =0xFA;     //Õ¼¿Õ±È1/640£¬ÖÐ¶Ï³ÖÐøÐÔ2£¬»ý·ÖÊ±¼ä9T£¬PSµçÔ´´ò¿ª
 323   1        conf_data[1] =0x03;     //PSÊä³ö16bits£¬½Ó½üÀë¿ª¶¼´¥·¢ÖÐ¶Ï
 324   1        VCNL4200_WriteOneWords(VCNL4200_PSCONF,conf_data);      
 325   1        conf_data[0] =0x6B;     //Âö³åÖØ¸´8£¬ÖÇÄÜ³ÖÐøÐÔ´ò¿ª£¬Ñ­»··¢ËÍ£¬ÆÕÍ¨±³¾°¹âÏû³ý
 326   1        conf_data[1] =0x0F;     //ÆÕÍ¨½Ó½ü²Ù×÷Ä£Ê½£¬ÆÕÍ¨¹âÕÕÄÜÁ¦£¬LEDÊä³ö200mA
 327   1        VCNL4200_WriteOneWords(VCNL4200_PSCONF2,conf_data); 
 328   1        conf_data[0] =0x4F;
 329   1        conf_data[1] =0x00;
 330   1        VCNL4200_WriteOneWords(VCNL4200_PSCANC,conf_data);  
 331   1        conf_data[0] =5;
 332   1        conf_data[1] =0x00;
 333   1        VCNL4200_WriteOneWords(VCNL4200_PSTHDL,conf_data);  
 334   1        conf_data[0] =10;
 335   1        conf_data[1] =0x00;
 336   1        VCNL4200_WriteOneWords(VCNL4200_PSTHDH,conf_data);  
 337   1      //  VCNL4200_WriteOneByte(VCNL4200_ALS_Para,0x0d);    //AMBIENT LIGHT PARAMETER:1)bit7 = 0 Á¬Ðø×ª»»Ä£Ê½Ñ¡Ôñ;
             -2)bit3=1,×Ô¶¯Æ«ÒÆ²¹³¥;3)bit2-bit0=5,Ã¿×ª»»Ò»´Î²âÁ¿µÄ´ÎÊý
 338   1      }
 339          
 340          //----------------------------------------------²âÁ¿º¯Êý--------------------------------------------------
             ---|
 341          /*void VCNL4200_Measurement(u16 *ProxResult,u16 *ALSResult)
 342          {
 343            VCNL4200_Init();                //³õÊ¼»¯VCNL4200
 344            VCNL4200_WriteOneByte(VCNL4200_CMD,0x98);   //Ð´ÃüÁî¼Ä´æÆ÷,¿ªÊ¼²âÁ¿
 345            delay_ms(10);
 346            while((VCNL4200_ReadOneByte(VCNL4200_CMD))&0x20 == 0);  //¼ì²âÃüÁî¼Ä´æÆ÷ÖÐProx_data_rdyÎ»£¬Îª1ÔòÊÇÒÑ×ª»»Íê
             -³É£¬Êý¾Ý¿É¶Á
 347            *ProxResult = ((u16)VCNL4200_ReadOneByte(VCNL4200_PROX_HSB)<<8) | VCNL4200_ReadOneByte(VCNL4200_PROX_LSB)
             -;
 348          
 349            while((VCNL4200_ReadOneByte(VCNL4200_CMD))&0x40 == 0);  //¼ì²âÃüÁî¼Ä´æÆ÷ÖÐAls_data_rdyÎ»£¬Îª1ÔòÊÇÒÑ×ª»»Íê³
             -É£¬Êý¾Ý¿É¶Á
 350            *ALSResult = ((u16)VCNL4200_ReadOneByte(VCNL4200_ALS_HSB)<<8) | VCNL4200_ReadOneByte(VCNL4200_ALS_LSB);
 351          
 352          } */
 353          
 354          
 355          
 356          // void VCNL4200_ReadAllRegisters(u8 *RegisterBuf)
 357          // {
C51 COMPILER V9.50a   VCNL4000                                                             08/27/2019 16:41:24 PAGE 7   

 358          //  u8 i=0;
 359          //  for(i=0;i<12;i++)
 360          //  {
 361          //    RegisterBuf[i]=VCNL4200_ReadOneByte(0x80+i);
 362          //  }
 363          // }
 364          
 365          void VCNL4200_MeasurementResult(u8 *ProxResult)     //»ñÈ¡²âÁ¿½á¹û
 366          {
 367   1        u8  conf_data[2];
 368   1      //  u16  TC_Status=0;
 369   1      //  VCNL4200_Init();                  //³õÊ¼»¯VCNL4200
 370   1      //  VCNL4200_WriteOneByte(VCNL4200_CMD,0x98);     //Ð´ÃüÁî¼Ä´æÆ÷,¿ªÊ¼²âÁ¿
 371   1        delay_ms(100);
 372   1        
 373   1      //  VCNL4200_ReadOneWords(VCNL4200_PSCONF2,conf_data);
 374   1      //  if(conf_data[0]&0x04)
 375   1        if(TC_Status==2)
 376   1        {
 377   2          conf_data[0] =0x6F;     //Âö³åÖØ¸´8£¬ÖÇÄÜ³ÖÐøÐÔ´ò¿ª£¬Ñ­»··¢ËÍ£¬ÆÕÍ¨±³¾°¹âÏû³ý
 378   2          conf_data[1] =0x0F;     //ÆÕÍ¨½Ó½ü²Ù×÷Ä£Ê½£¬ÆÕÍ¨¹âÕÕÄÜÁ¦£¬LEDÊä³ö200mA
 379   2          VCNL4200_WriteOneWords(VCNL4200_PSCONF2,conf_data); 
 380   2          VCNL4200_ReadOneWords(VCNL4200_PSDATA,ProxResult);  
 381   2          if((ProxResult[0]!=0)||(ProxResult[1]!=0))
 382   2          {
 383   3      //      conf_data[0] =0x6B;     //Âö³åÖØ¸´8£¬ÖÇÄÜ³ÖÐøÐÔ´ò¿ª£¬Ñ­»··¢ËÍ£¬ÆÕÍ¨±³¾°¹âÏû³ý
 384   3      //      conf_data[1] =0x0F;     //ÆÕÍ¨½Ó½ü²Ù×÷Ä£Ê½£¬ÆÕÍ¨¹âÕÕÄÜÁ¦£¬LEDÊä³ö200mA
 385   3      //      VCNL4200_WriteOneWords(VCNL4200_PSCONF2,conf_data); 
 386   3          
 387   3            TC_Status=1;
 388   3            TC_Status_Old=TC_Status;
 389   3            write_dgus_vp(SWITCH,(u8*)&TC_Status,1);
 390   3            Boot_Handler();
 391   3          }
 392   2        }
 393   1        write_dgus_vp(0x1110,ProxResult,1);
 394   1      //  VCNL4200_ReadOneWords(VCNL4200_PSDATA+1,ProxResult);  
 395   1      //  VCNL4200_ReadOneWords(VCNL4200_PSDATA+2,ProxResult);  
 396   1      //  VCNL4200_ReadOneWords(VCNL4200_PSDATA+5,ProxResult);  
 397   1      //  VCNL4200_ReadOneWords(VCNL4200_PSDATA+6,ProxResult);  
 398   1      //  while((VCNL4200_ReadOneWords(0x80)&0x60 != 0x60));  //ÅÐ¶ÏÁ½¸ö²âÁ¿ÊÇ·ñ¶¼Íê³É
 399   1      //  *AlsResult = (u16)VCNL4200_ReadOneByte(VCNL4200_ALS_HSB)<<8 | VCNL4200_ReadOneByte(VCNL4200_ALS_LSB);
 400   1      //  *ProxResult = (u16)VCNL4200_ReadOneByte(VCNL4200_PROX_HSB)<<8 | VCNL4200_ReadOneByte(VCNL4200_PROX_LSB
             -);
 401   1      }
 402          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    882    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
