C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE CONTROL
OBJECT MODULE PLACED IN .\obj\control.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE control.c LARGE OBJECTADVANCED BROWSE INCDIR(..\T5L51) DEBUG PRINT(.\Listin
                    -gs\control.lst) TABS(2) OBJECT(.\obj\control.obj)

line level    source

   1          /******************************************************************************
   2          
   3                            版权所有 (C), 2019, 北京迪文科技有限公司
   4          
   5           ******************************************************************************
   6            文 件 名   : control.c
   7            版 本 号   : V2.0
   8            作    者   : chengjing
   9            生成日期   : 2019年5月14日
  10            功能描述   : 串口函数
  11            修改历史   :
  12            1.日    期   : 
  13              作    者   : 
  14              修改内容   : 
  15          ******************************************************************************/
  16          
  17          #include "control.h"
  18          #include "config.h"
  19          #include "uart.h"
  20          #include "stdlib.h"
  21          
  22          
  23          
  24          //实时温度显示值
  25          u16 Temper_Display_Val=0;
  26          u16 Temper_Display_Val_Dec=0;
  27          //设定温度显示值
  28          u16 Set_Temper_Display_Val=0;
  29          u16 Set_Temper_Display_Val_Dec=0;
  30          //实时温度旧值
  31          u16 Temperature_Val_Old=0;
  32          //设定温度旧值
  33          u16 Set_Temperature_Val_Old=0;
  34          //定时器123开启标志位
  35          u16 timer_key[3]={0};
  36          //定时器时段风速模式数据保存
  37          timer_period  tim_per_val[3][4]={0};
  38          //云变量定时器星期值
  39          u16 tim_week_c[3]={0};
  40          //定时器123定时星期
  41          u16 timer_week[3][7]={0};
  42          //定时器开关选择
  43          u16 tim_k=0;
  44          //时分
  45          u16 Hour_Min_R=0;
  46          //有进行时间设置
  47          u16 Timer_Parm_Read_Flag=0;
  48          //定时器123触发标志
  49          u8 timer_trigger_flag[3]={0};
  50          //主界面配置参数
  51          u16 data Wind_Speed=0;
  52          u16 data Wind_Speed_Old=0;
  53          u16 data Wind_Speed_Val=0;
  54          u16 Wind_Speed_Old_Val=0;
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 2   

  55          u16 data Mode=0;
  56          u16 data Mode_old=0;
  57          u16 data Mode_Val=0;
  58          u16 Mode_Old_Val=0;
  59          u16 movie_icon = 0;
  60          //风速模式配置标志
  61          u16 Wind_Speed_Config_Flag=0;
  62          u16 Mode_Config_Flag=0;
  63          u16 Wind_Speed_Mode_Config_Flag=0;
  64          //实际温度是否达到设定温度值标志
  65          u16 xdata Temperature_To_Set_Flag=0;
  66          //风速是否改变标志  0：风速没有改变，0x01：风速改变，风速阀没有关闭，0x10：风速阀已关闭
  67          u16 xdata Wind_Set_Flag=0;  
  68          //模式改变标志，需要改变继电器
  69          u16 xdata Mode_Set_Flag=0;    
  70          
  71          u8  yuyin_state[2]={0};
  72          
  73          
  74          u8  SpeakCmd[4] = {0x01,0x01,0x40,0x00};
  75          
  76          /******************CRC 校验表格************************/
  77          unsigned char code CRCTABH[256]=
  78          {0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1, 
  79            0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,
  80            0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,
  81            0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
  82            0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,
  83            0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
  84            0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,
  85            0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
  86            0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,
  87            0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,
  88            0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,
  89            0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,
  90            0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,
  91            0x81,0x40,0x00,0xc1,0x81, 0x40,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,
  92            0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41, 0x00,0xc1,0x81,0x40,0x01,0xc0,
  93            0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01, 0xc0,0x80,0x41,
  94            0x01,0xc0,0x80,0x41,0x00,0xc1,0x81,0x40,0x00,0xc1,0x81,0x40,0x01,0xc0, 
  95            0x80,0x41,0x00,0xc1,0x81,0x40,0x01,0xc0,0x80,0x41,0x01,0xc0,0x80,0x41,0x00,0xc1,0x81, 0x40};
  96          unsigned char code CRCTABL[256]=
  97          {0x00,0xc0,0xc1,0x01,0xc3,0x03,0x02,0xc2,0xc6,0x06,0x07,0xc7,0x05,0xc5,0xc4,0x04,0xcc, 
  98            0x0c,0x0d,0xcd,0x0f,0xcf,0xce,0x0e,0x0a,0xca,0xcb,0x0b,0xc9,0x09,0x08,0xc8,0xd8,0x18, 
  99            0x19,0xd9,0x1b,0xdb,0xda,0x1a,0x1e,0xde,0xdf,0x1f,0xdd,0x1d,0x1c,0xdc,0x14,0xd4,0xd5, 
 100            0x15,0xd7,0x17,0x16,0xd6,0xd2,0x12,0x13,0xd3,0x11,0xd1,0xd0,0x10,0xf0,0x30,0x31,0xf1, 
 101            0x33,0xf3,0xf2,0x32,0x36,0xf6,0xf7,0x37,0xf5,0x35,0x34,0xf4,0x3c,0xfc,0xfd,0x3d,0xff,0x3f, 
 102            0x3e,0xfe,0xfa,0x3a,0x3b,0xfb,0x39,0xf9,0xf8,0x38,0x28,0xe8,0xe9,0x29,0xeb,0x2b,0x2a,0xea, 
 103            0xee,0x2e,0x2f,0xef,0x2d,0xed,0xec,0x2c,0xe4,0x24,0x25,0xe5,0x27,0xe7,0xe6,0x26,0x22,0xe2, 
 104            0xe3,0x23,0xe1,0x21,0x20,0xe0,0xa0,0x60,0x61,0xa1,0x63,0xa3,0xa2,0x62,0x66,0xa6,0xa7, 
 105            0x67,0xa5,0x65,0x64,0xa4,0x6c,0xac,0xad,0x6d,0xaf,0x6f,0x6e,0xae,0xaa,0x6a,0x6b,0xab,0x69, 
 106            0xa9,0xa8,0x68,0x78,0xb8,0xb9,0x79,0xbb,0x7b,0x7a,0xba,0xbe,0x7e,0x7f,0xbf,0x7d,0xbd,0xbc, 
 107            0x7c,0xb4,0x74,0x75,0xb5,0x77,0xb7,0xb6,0x76,0x72,0xb2,0xb3,0x73,0xb1,0x71,0x70,0xb0, 
 108            0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9c, 
 109            0x5c,0x5d,0x9d,0x5f,0x9f,0x9e,0x5e,0x5a,0x9a,0x9b,0x5b,0x99,0x59,0x58,0x98,0x88,0x48, 
 110            0x49,0x89,0x4b,0x8b,0x8a,0x4a,0x4e,0x8e,0x8f,0x4f,0x8d,0x4d,0x4c,0x8c,0x44,0x84,0x85, 
 111            0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40};
 112          
 113          
 114          
 115          void Calculate_CRC16(unsigned char *Buff, unsigned int len);
 116          
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 3   

 117          void ModePage_Set(void)
 118          {
 119   1        read_dgus_vp(PIC_NOW,(u8*)&PageNow,1);
 120   1        read_dgus_vp(MODE,(u8 *)&Mode,1);
 121   1        switch (Mode)
 122   1        {
 123   2          case 1: 
 124   2          {
 125   3            if((PageNow==2)||(PageNow==1))
 126   3            {
 127   4              Return_Main_page();break;
 128   4            } 
 129   3            break;
 130   3          }     //制冷
 131   2          case 2: 
 132   2          {
 133   3            if((PageNow==1)||(PageNow==3))
 134   3            {
 135   4              Return_Main_page();break;
 136   4            } 
 137   3            break;    //制热
 138   3          } 
 139   2          case 3:
 140   2          {
 141   3            if((PageNow==2)||(PageNow==3))
 142   3            {
 143   4              Return_Main_page();break;
 144   4            } 
 145   3          break;      //送风
 146   3          } 
 147   2          default: Return_Main_page();break;
 148   2        }
 149   1      }
 150          
 151          /*****************************************************************************
 152           函 数 名  : void Control_Function(void)
 153           功能描述  : 温控器控制函数
 154           输入参数  :  
 155           输出参数  : 
 156           修改历史  :
 157            1.日    期   : 2019年4月30日
 158              作    者   : chengjing
 159              修改内容   : 创建
 160          *****************************************************************************/
 161          void Control_Function(void)
 162          {
 163   1        Key_Handler();            //按键处理
 164   1        Display_Temperature();        //显示实时温度和设定温度
 165   1        ModePage_Set();   //模式及页面处理
 166   1        Get_Temperature(Temp_time,Temp_Freq);         //得到实时温度
 167   1        Timer_Config_Handler();       //定时器处理
 168   1        if((Close_Valve_Flag&0x01)==0x01) //休眠状态不能进行亮度处理
 169   1        {
 170   2          Close_Valve();            //关闭继电器    
 171   2        }
 172   1        else
 173   1        {
 174   2          Mode_Wind_Speed_Handler();    //温度风速控制
 175   2          Brightness_Handler();     //亮度处理
 176   2        }
 177   1        Alarm_Handler();          //闹钟处理  T5L暂时没有闹钟功能
 178   1        Sleep_Handler();          //休眠处理  
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 4   

 179   1        TC_Status_Check_Handler();      //检查温控器状态是否休眠
 180   1      }
 181          
 182          
 183          
 184          
 185          
 186          
 187          /*****************************************************************************
 188           函 数 名  : void Display_Temperature(void)
 189           功能描述  : 当前温度显示和设定温度显示，有小数点显示，整数位当前温度值/10，
 190                小数位当前温度%10
 191           输入参数  :   
 192           输出参数  : 
 193           修改历史  :
 194            1.日    期   : 2019年5月2日
 195              作    者   : chengjing
 196              修改内容   : 创建
 197          *****************************************************************************/
 198          void Display_Temperature(void)
 199          {
 200   1        read_dgus_vp(TEMP_CURRENT,(u8*)&Temperature_Real,1);
 201   1        if(Temperature_Real!=Temperature_Val_Old)
 202   1        {
 203   2          Temperature_Val_Old=Temperature_Real;
 204   2          Temper_Display_Val=Temperature_Real/10;
 205   2          Temper_Display_Val_Dec=Temperature_Real%10;
 206   2          write_dgus_vp(TEMP_REAL_VALUE,(u8*)&Temper_Display_Val,1);
 207   2          write_dgus_vp(TEMP_REAL_VAL_DEC,(u8*)&Temper_Display_Val_Dec,1);
 208   2        }
 209   1        read_dgus_vp(TEMP_SET,(u8*)&Temperature_Set_Val,1);
 210   1        if(Set_Temperature_Val_Old!=Temperature_Set_Val)
 211   1        {
 212   2          Set_Temperature_Val_Old=Temperature_Set_Val;
 213   2          Set_Temper_Display_Val=Temperature_Set_Val/10;
 214   2          Set_Temper_Display_Val_Dec=Temperature_Set_Val%10;
 215   2          write_dgus_vp(SET_TEMP_VALUE,(u8*)&Set_Temper_Display_Val,1);
 216   2          write_dgus_vp(SET_TEMP_VAL_DEC,(u8*)&Set_Temper_Display_Val_Dec,1);
 217   2        }
 218   1      }
 219          
 220          
 221          /*****************************************************************************
 222           函 数 名  : void Timer_Config_Handler(void)
 223           功能描述  : 定时器配置处理，根据定时器设置参数，处理定时器配置参数
 224           输入参数  :   
 225           输出参数  : 
 226           修改历史  :
 227            1.日    期   : 2019年5月15日
 228              作    者   : chengjing
 229              修改内容   : 创建
 230          *****************************************************************************/
 231          void Timer_Config_Handler(void)
 232          {
 233   1        u8 i=0;
 234   1        read_dgus_vp(TIMER_KEY,(u8*)timer_key,3);
 235   1        if((timer_key[0]>0)||(timer_key[1]>0)||(timer_key[2]>0))
 236   1        {
 237   2          for(tim_k=0;tim_k<3;tim_k++)
 238   2          {
 239   3            if(timer_key[tim_k]==1)
 240   3            {               
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 5   

 241   4              if(timer_week[tim_k][real_time.week]==1)    //星期有处于设置状态
 242   4              {     
 243   5                Hour_Min_R=(u16)real_time.hour*256+real_time.min;
 244   5                for(i=0;i<4;i++)
 245   5                {
 246   6                  if(tim_per_val[tim_k][i].timer_time_start==tim_per_val[tim_k][i].timer_time_end)
 247   6                  {
 248   7                    return;
 249   7                  }
 250   6                  else
 251   6                  {
 252   7                    if((Hour_Min_R==tim_per_val[tim_k][i].timer_time_start)&&(timer_trigger_flag[tim_k]!=i+1))
 253   7                    {
 254   8                      if((tim_per_val[tim_k][i].timer_speed==0)||(tim_per_val[tim_k][i].time_temperture==0))
 255   8                      {
 256   9                        return;
 257   9                      }
 258   8                      else
 259   8                      {
 260   9                        if(tim_per_val[tim_k][i].timer_speed==5)
 261   9                        {
 262  10                          Standby_Handler();
 263  10                        }
 264   9                        else
 265   9                        {
 266  10                          write_dgus_vp(SPEED,(u8*)&tim_per_val[tim_k][i].timer_speed,1);
 267  10                          write_dgus_vp(TEMP_SET,(u8*)&tim_per_val[tim_k][i].time_temperture,1);
 268  10                        }
 269   9                        timer_trigger_flag[tim_k]=i+1;
 270   9                      }
 271   8                    }
 272   7                  }
 273   6                }
 274   5              }             
 275   4            }   
 276   3          }
 277   2          Timer_Status=1; 
 278   2          write_dgus_vp(TIMER_STATUS,(u8*)&Timer_Status,1);
 279   2        }
 280   1        else
 281   1        {
 282   2          Timer_Status=0; 
 283   2          write_dgus_vp(TIMER_STATUS,(u8*)&Timer_Status,1);
 284   2        }
 285   1        return;
 286   1      }
 287          
 288          /*****************************************************************************
 289           函 数 名  : void TC_Status_Check_Handler(void)
 290           功能描述  : 温控器状态监测，主要是处理APP端下发的休眠和开机
 291           输入参数  :    
 292           输出参数  : 
 293           修改历史  :
 294            1.日    期   : 2019年5月12日
 295              作    者   : chengjing
 296              修改内容   : 创建
 297          *****************************************************************************/
 298          void TC_Status_Check_Handler(void)
 299          {
 300   1        read_dgus_vp(SWITCH,(u8*)&TC_Status,1);
 301   1        if((TC_Status==2)&&(TC_Status!=TC_Status_Old))
 302   1        {
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 6   

 303   2          write_dgus_vp(LED_CONFIG,led_off,2);              
 304   2          Close_Valve_Flag = 0x01;      //不干扰判断休眠态
 305   2          Valve_Config_Flag=0;
 306   2          TC_Status_Old=TC_Status;
 307   2        }
 308   1        if((TC_Status==1)&&(TC_Status!=TC_Status_Old))
 309   1        {
 310   2          Boot_Handler();
 311   2        }
 312   1      }
 313          
 314          /*****************************************************************************
 315           函 数 名  : void Wind_Speed_Val_Handler(void)
 316           功能描述  : 将风速智能模式改为普通模式，简化控制逻辑
 317           输入参数  :    
 318           输出参数  : 
 319           修改历史  :
 320            1.日    期   : 2019年5月12日
 321              作    者   : chengjing
 322              修改内容   : 创建
 323          *****************************************************************************/
 324          void Wind_Speed_Val_Handler(void)
 325          {
 326   1        read_dgus_vp(SPEED,(u8*)&Wind_Speed,1);
 327   1        if(Wind_Speed==4)
 328   1        {
 329   2          if(abs(Temperature_Real-Temperature_Set_Val)>=40)
 330   2          {
 331   3            Wind_Speed_Val=3;
 332   3          }
 333   2          else if(abs(Temperature_Real-Temperature_Set_Val)>=20)
 334   2          {
 335   3            Wind_Speed_Val=2;
 336   3          }
 337   2          else
 338   2          {
 339   3            Wind_Speed_Val=1;
 340   3          }
 341   2        }
 342   1        else
 343   1        {
 344   2          Wind_Speed_Val=Wind_Speed;
 345   2        }
 346   1        if(Wind_Speed_Val!=Wind_Speed_Old_Val)
 347   1        {
 348   2          if((Wind_Set_Flag==0x01)||(Wind_Set_Flag==0x10))
 349   2          {
 350   3            //空
 351   3          }
 352   2          else
 353   2          {
 354   3            Wind_Set_Flag = 0x01;
 355   3            Wait_Count=0;
 356   3          }
 357   2        }
 358   1        else
 359   1        {
 360   2          if(Wind_Set_Flag!=0x10)
 361   2          {
 362   3            Wind_Set_Flag=0;
 363   3          }
 364   2        }
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 7   

 365   1      }
 366          
 367          
 368          /*****************************************************************************
 369           函 数 名  : void Wind_Speed_Control_Handler(void)
 370           功能描述  : 风速控制
 371                将风速智能模式改为普通模式，简化控制逻辑
 372           输入参数  :    
 373           输出参数  : 
 374           修改历史  :
 375            1.日    期   : 2019年5月12日
 376              作    者   : chengjing
 377              修改内容   : 创建
 378          *****************************************************************************/
 379          void Wind_Speed_Control_Handler(void)
 380          { 
 381   1        if(Temperature_To_Set_Flag==0)    //温度没有达到设定温度
 382   1        {
 383   2          Wind_Speed_Val_Handler();       
 384   2          if(Wind_Set_Flag==0)      //风速没有改变
 385   2          {
 386   3            if(Wind_Speed_Config_Flag==0)   //首次配置
 387   3            {
 388   4              if(Wind_Speed_Val==1)
 389   4              {
 390   5                Low_Speed_Valve=1;
 391   5                Medium_Speed_Valve=0;
 392   5                High_Speed_Valve=0;
 393   5              }
 394   4              else if(Wind_Speed_Val==2)
 395   4              {
 396   5                Low_Speed_Valve=0;
 397   5                Medium_Speed_Valve=1;
 398   5                High_Speed_Valve=0;
 399   5              }
 400   4              else if(Wind_Speed_Val==3)
 401   4              {
 402   5                Low_Speed_Valve=0;
 403   5                Medium_Speed_Valve=0;
 404   5                High_Speed_Valve=1;
 405   5              }
 406   4              Wait_Count=0;
 407   4              Wind_Speed_Config_Flag=1;
 408   4              Speed_Valve_Status=1;
 409   4              write_dgus_vp(SPEED_VALVE,(u8*)&Speed_Valve_Status,1);
 410   4            }     
 411   3          }
 412   2          else  //风速改变
 413   2          {     
 414   3            if(Wind_Set_Flag==0x01)
 415   3            {
 416   4              if(Wait_Count>1000)
 417   4              {
 418   5                Medium_Speed_Valve=0;
 419   5                High_Speed_Valve=0;
 420   5                Low_Speed_Valve=0;
 421   5                Wind_Set_Flag = 0x10; //已关闭风速
 422   5                Wait_Count=0;   //重新计数          
 423   5                Wind_Speed_Old_Val=Wind_Speed_Val;
 424   5              }
 425   4            }
 426   3            if(Wind_Set_Flag==0x10)
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 8   

 427   3            {
 428   4              if(Wait_Count>1000)
 429   4              {
 430   5                Wind_Speed_Old_Val=Wind_Speed_Val;
 431   5                Wind_Set_Flag=0;
 432   5                Wind_Speed_Config_Flag=0;
 433   5              }
 434   4            }
 435   3          }
 436   2        }
 437   1      }
 438          
 439          /*****************************************************************************
 440           函 数 名  : void Mode_Val_Handler(void)
 441           功能描述  : 将模式简化为开启和关闭两个状态
 442           输入参数  :    
 443           输出参数  : 
 444           修改历史  :
 445            1.日    期   : 2019年5月12日
 446              作    者   : chengjing
 447              修改内容   : 创建
 448          *****************************************************************************/
 449          void Mode_Val_Handler(void)
 450          {
 451   1        read_dgus_vp(MODE,(u8*)&Mode,1);
 452   1        if(Temperature_Real>Temperature_Set_Val)
 453   1        {
 454   2          if(Mode==1)
 455   2          {
 456   3            Mode_Val=1;
 457   3          }
 458   2          else
 459   2          {
 460   3            Mode_Val=0;
 461   3          }
 462   2          if(Mode_Val!=Mode_Old_Val)
 463   2          {     
 464   3            if(Mode_Set_Flag!=0x01)
 465   3            {
 466   4              Mode_Set_Flag=0x01;
 467   4              Wait_Count=0;
 468   4            }
 469   3          }
 470   2        }
 471   1        else if(Temperature_Real<Temperature_Set_Val)
 472   1        {
 473   2          if(Mode==2)
 474   2          {
 475   3            Mode_Val=1;
 476   3          }
 477   2          else
 478   2          {
 479   3            Mode_Val=0;
 480   3          }
 481   2          if(Mode_Val!=Mode_Old_Val)
 482   2          {     
 483   3            if(Mode_Set_Flag!=0x01)
 484   3            {
 485   4              Mode_Set_Flag=0x01;
 486   4              Wait_Count=0;
 487   4            }
 488   3          }
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 9   

 489   2        }
 490   1      }
 491          
 492          /*****************************************************************************
 493           函 数 名  : void Mode_Control_Handler(void)
 494           功能描述  : 依据开启或关闭水阀值，实现模式控制
 495           输入参数  :    
 496           输出参数  : 
 497           修改历史  :
 498            1.日    期   : 2019年5月12日
 499              作    者   : chengjing
 500              修改内容   : 创建
 501          *****************************************************************************/
 502          void Mode_Control_Handler(void)
 503          {
 504   1        if((Temperature_To_Set_Flag==0)&&(Wind_Set_Flag==0))    //温度没有达到设定温度
 505   1        {
 506   2          Mode_Val_Handler();
 507   2          if(Mode_Set_Flag==0)      //模式没有改变
 508   2          {
 509   3            if(Mode_Config_Flag==0)   //首次配置
 510   3            {
 511   4              if(Mode_Val==1)
 512   4              {
 513   5                Water_Valve=1;
 514   5                Water_Valve_Status=1;
 515   5                write_dgus_vp(WATER_VALVE,(u8*)&Water_Valve_Status,1);
 516   5              }
 517   4              else
 518   4              {
 519   5                Water_Valve=0;
 520   5                Water_Valve_Status=0;
 521   5                write_dgus_vp(WATER_VALVE,(u8*)&Water_Valve_Status,1);
 522   5              }
 523   4              Mode_Config_Flag=1;
 524   4            }
 525   3          }
 526   2          else
 527   2          {
 528   3            if(Mode_Set_Flag==0x01)
 529   3            {
 530   4              if(Wait_Count>1000)
 531   4              {
 532   5                Mode_Config_Flag=0;
 533   5                Mode_Set_Flag=0;
 534   5                Mode_Old_Val=Mode_Val;
 535   5              }
 536   4            }
 537   3          }
 538   2        }
 539   1      }
 540          
 541          
 542          /*****************************************************************************
 543           函 数 名  : void Mode_Temperature_Handler(void)
 544           功能描述  : 处于个模式下，温度是否达标和达标后降温检测处理
 545           输入参数  :    
 546           输出参数  : 
 547           修改历史  :
 548            1.日    期   : 2019年5月12日
 549              作    者   : chengjing
 550              修改内容   : 创建
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 10  

 551          *****************************************************************************/
 552          void Mode_Temperature_Handler(void)
 553          {
 554   1        if((Wind_Set_Flag==0)&&(Mode_Set_Flag==0))
 555   1        {
 556   2          if(Temperature_To_Set_Flag==0)    //温度没有达到设定温度
 557   2          {
 558   3            if(Mode==1)       //制冷
 559   3            {
 560   4              if(Temperature_Real<=Temperature_Set_Val)
 561   4              {
 562   5                Temperature_To_Set_Flag=1;
 563   5                Wait_Count=0;
 564   5                Close_Valve_Flag=0x01;
 565   5                Valve_Config_Flag=0;
 566   5              }
 567   4            }
 568   3            else if(Mode==2)    //制热
 569   3            {     
 570   4              if(Temperature_Real>=Temperature_Set_Val)
 571   4              {
 572   5                Temperature_To_Set_Flag=1;
 573   5                Wait_Count=0;
 574   5                Close_Valve_Flag=0x01;
 575   5                Valve_Config_Flag=0;
 576   5              }
 577   4            }
 578   3          }
 579   2          else
 580   2          {
 581   3            if(Mode==1)   //制冷
 582   3            {
 583   4              if((Temperature_Real-20)>=Temperature_Set_Val)
 584   4              {
 585   5                Temperature_To_Set_Flag=0;
 586   5                Wind_Speed_Old_Val=0;
 587   5                Mode_Old_Val=0;
 588   5              }
 589   4            }
 590   3            else if(Mode==2)    //制热
 591   3            {
 592   4              if((Temperature_Set_Val-20)>=Temperature_Real)
 593   4              {
 594   5                Temperature_To_Set_Flag=0;
 595   5                Wind_Speed_Old_Val=0;
 596   5                Mode_Old_Val=0;
 597   5              }
 598   4            }
 599   3            else if(Mode==3)    //送风
 600   3            {
 601   4              Temperature_To_Set_Flag=0;
 602   4              Wind_Speed_Old_Val=0;
 603   4            }
 604   3          }
 605   2        }
 606   1      }
 607          
 608          
 609          /*****************************************************************************
 610           函 数 名  : void Mode_Wind_Speed_Handler(void)
 611           功能描述  : 模式风速处理函数
 612           输入参数  :   
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 11  

 613           输出参数  : 
 614           修改历史  :
 615            1.日    期   : 2019年4月2日
 616              作    者   : chengjing
 617              修改内容   : 创建
 618          *****************************************************************************/
 619          void Mode_Wind_Speed_Handler(void)
 620          {
 621   1        Wind_Speed_Control_Handler();
 622   1        Mode_Control_Handler();
 623   1        Mode_Temperature_Handler();
 624   1      }
 625          //串口2处理函数
 626          void  uart2com(void)
 627          {
 628   1        u32   DGUS_addr;
 629   1        u8    trans_data[200]={0};
 630   1        if(uart2_rx_count != 0)
 631   1        {
 632   2          if(Uart2_TTL_Status == 0)
 633   2          {
 634   3            uart2_rx_count = 0;
 635   3            if((Uart2_Rx[0] == 0x5A)&&(Uart2_Rx[1] == 0xA5))
 636   3            {
 637   4              if(Uart2_Rx[3] == 0x82)
 638   4              {
 639   5                DGUS_addr = (u32)(Uart2_Rx[4]<<8)|Uart2_Rx[5];
 640   5                write_dgus_vp(DGUS_addr,(u8*)&Uart2_Rx[6],Uart2_Rx[2]-3);
 641   5                trans_data[0]=0x5A;
 642   5                trans_data[1]=0xA5;
 643   5                trans_data[2]=0x4F;
 644   5                trans_data[3]=0x4B;
 645   5                UART2_SendStr(trans_data,4);
 646   5              }
 647   4              if(Uart2_Rx[3] == 0x83)
 648   4              {
 649   5                DGUS_addr = (u32)(Uart2_Rx[4]<<8)|Uart2_Rx[5];
 650   5                read_dgus_vp(DGUS_addr,(u8*)&trans_data[7],Uart2_Rx[6]);
 651   5                trans_data[0]=0x5A;
 652   5                trans_data[1]=0xA5;
 653   5                trans_data[2]=Uart2_Rx[6]*2+4;
 654   5                trans_data[3]=0x83;
 655   5                trans_data[4]=Uart2_Rx[4];
 656   5                trans_data[5]=Uart2_Rx[5];
 657   5                trans_data[6]=Uart2_Rx[6];
 658   5                UART2_SendStr(trans_data,trans_data[2]+3);
 659   5              }
 660   4            }
 661   3          }
 662   2        }
 663   1      }
 664          void M4G6_DataDeal(u8 dat)
 665          {
 666   1        u16  Ttemp,ii;
 667   1              page_set[0]=0x5A;
 668   1              page_set[1]=0x01;
 669   1              page_set[2]=0x00;
 670   1              page_set[3]=30;
 671   1          ii = dat;
 672   1      //        write_dgus_vp(0x3400,(u8*)&ii,1);
 673   1        
 674   1          switch(dat)
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 12  

 675   1          {
 676   2            case  0:    //"接收超时"
 677   2              page_set[0]=0x00;
 678   2      //        SpeakCmd[0] = 0;  
 679   2      //        SpeakCmd[1] = 1;    
 680   2      //        SpeakCmd[2] = 0x18;
 681   2      //        SpeakCmd[3] = 0;        
 682   2      //        write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"没有听清"
 683   2              yuyin_state[0]=0;
 684   2              yuyin_state[1]=0; 
 685   2            break;
 686   2            case  1:    //"你好小迪"
 687   2              SpeakCmd[0] = 1;  
 688   2              SpeakCmd[1] = 1;    
 689   2              SpeakCmd[2] = 0x18;
 690   2              SpeakCmd[3] = 0;        
 691   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"主人我在"
 692   2      //              write_dgus_vp(TEST_VP1,SpeakCmd,2);
 693   2              do
 694   2              {
 695   3                read_dgus_vp(SPEAK_VP,(u8*)&SpeakCmd[0],1);
 696   3              }while(SpeakCmd[1]);
 697   2              yuyin_state[0]=1;
 698   2              yuyin_state[1]=0;
 699   2              
 700   2              break;  
 701   2            case  2:    //"升高温度"
 702   2              SpeakCmd[0] = 2;      
 703   2              SpeakCmd[1] = 1;    
 704   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"当前温度"
 705   2            
 706   2              yuyin_state[0]=2;
 707   2              yuyin_state[1]=1;   //0201,表示2级菜单，温度增加
 708   2              delay_ms(1500);
 709   2              SpeakCmd[0] = Temperature_Real/100;
 710   2            if(SpeakCmd[0]!=0)
 711   2            {
 712   3              SpeakCmd[0] += 29;
 713   3              SpeakCmd[1] = 1;    
 714   3              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"温度十位"
 715   3              delay_ms(1500);
 716   3            }
 717   2              SpeakCmd[0] = (Temperature_Real%100)/10+ 20;
 718   2              SpeakCmd[1] = 1;    
 719   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"温度个位"
 720   2              
 721   2              delay_ms(1000);
 722   2              SpeakCmd[0] = 40;
 723   2              SpeakCmd[1] = 1;    
 724   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"主人想要多少度"
 725   2              
 726   2              delay_ms(2500);
 727   2              break;
 728   2            case  3:    //"开始制冷"
 729   2              SpeakCmd[0] = 5;      
 730   2              SpeakCmd[1] = 1;    
 731   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"制冷启动"
 732   2              
 733   2              Mode=1;
 734   2              write_dgus_vp(MODE,(u8*)&Mode,1);
 735   2              Speed_Auto_Set_Handler();
 736   2              yuyin_state[0]=0;
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 13  

 737   2              yuyin_state[1]=0; 
 738   2              break;
 739   2      //            //"设定风速"
 740   2      //              SpeakCmd[0] = 03;     
 741   2      //              SpeakCmd[1] = 1;    
 742   2      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"当前风速"
 743   2      //              delay_ms(1000);
 744   2      //              
 745   2      //              
 746   2      //              SpeakCmd[0] = Wind_Speed_Val+20;
 747   2      //              SpeakCmd[1] = 1;    
 748   2      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"档位"
 749   2      //              delay_ms(500);
 750   2      //              SpeakCmd[0] = 4;
 751   2      //              SpeakCmd[1] = 1;    
 752   2      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"想要多少档"
 753   2      //              delay_ms(500);
 754   2      //              break;
 755   2            case  4:    
 756   2              SpeakCmd[0] = 6;      
 757   2              SpeakCmd[1] = 1;    
 758   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"制热启动" 
 759   2              Mode=2;
 760   2              write_dgus_vp(MODE,(u8*)&Mode,1);
 761   2              Speed_Auto_Set_Handler();
 762   2              yuyin_state[0]=0;
 763   2              yuyin_state[1]=0; 
 764   2              break;
 765   2            case  5: 
 766   2              SpeakCmd[0] = 7;      
 767   2              SpeakCmd[1] = 1;    
 768   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"停止工作" 
 769   2              
 770   2              Standby_Handler();      //休眠
 771   2              yuyin_state[0]=0;
 772   2              yuyin_state[1]=0; 
 773   2              break;
 774   2            case  6:  
 775   2              SpeakCmd[0] = 8;      
 776   2              SpeakCmd[1] = 1;    
 777   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
 778   2              if(Mode == 1)
 779   2              {
 780   3                Speed_Low_Set_Handler();
 781   3              }
 782   2              else
 783   2              {
 784   3                Wind_Speed++;
 785   3                if(Wind_Speed>3)
 786   3                {
 787   4                  Wind_Speed=3;
 788   4                }
 789   3                write_dgus_vp(SPEED,(u8*)&Wind_Speed,1);
 790   3              }
 791   2              Temperature_Set_Increase();
 792   2              Temperature_Set_Confirm_Handler();
 793   2              yuyin_state[0]=0;
 794   2              yuyin_state[1]=0; 
 795   2            break;
 796   2            case  7:  
 797   2              SpeakCmd[0] = 8;      
 798   2              SpeakCmd[1] = 1;    
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 14  

 799   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
 800   2              if(Mode == 1)
 801   2              {
 802   3                Close_Valve_Flag=0x01;
 803   3                Valve_Config_Flag=0;
 804   3                TC_Status=2;
 805   3                TC_Status_Old=TC_Status;
 806   3                write_dgus_vp(SWITCH,(u8*)&TC_Status,1);  //温控器状态休眠
 807   3              }
 808   2              else
 809   2              {
 810   3                
 811   3                Speed_High_Set_Handler();
 812   3                Temperature_Set_Increase();
 813   3                Temperature_Set_Increase();
 814   3                read_dgus_vp(TEMPERATURE_PRECISION,(u8*)&ii,1);
 815   3                if(ii==0)
 816   3                {
 817   4                  Temperature_Set_Increase();
 818   4                  Temperature_Set_Increase();
 819   4                }
 820   3                Temperature_Set_Confirm_Handler();
 821   3              }
 822   2              yuyin_state[0]=0;
 823   2              yuyin_state[1]=0; 
 824   2              break;
 825   2            case  8:  
 826   2              SpeakCmd[0] = 8;      
 827   2              SpeakCmd[1] = 1;    
 828   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
 829   2              if(Mode == 2)
 830   2              {
 831   3                Speed_Low_Set_Handler();
 832   3              }
 833   2              else
 834   2              {
 835   3                Wind_Speed++;
 836   3                if(Wind_Speed>3)
 837   3                {
 838   4                  Wind_Speed=3;
 839   4                }
 840   3                write_dgus_vp(SPEED,(u8*)&Wind_Speed,1);
 841   3              }
 842   2              Tmeperature_Set_Decrease();
 843   2              Temperature_Set_Confirm_Handler();
 844   2              yuyin_state[0]=0;
 845   2              yuyin_state[1]=0; 
 846   2              break;
 847   2            case  9:  
 848   2              SpeakCmd[0] = 8;      
 849   2              SpeakCmd[1] = 1;    
 850   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
 851   2              if(Mode == 2)
 852   2              {
 853   3                Close_Valve_Flag=0x01;
 854   3                Valve_Config_Flag=0;
 855   3                TC_Status=2;
 856   3                TC_Status_Old=TC_Status;
 857   3                write_dgus_vp(SWITCH,(u8*)&TC_Status,1);  //温控器状态休眠
 858   3              }
 859   2              else
 860   2              {
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 15  

 861   3                
 862   3                Speed_High_Set_Handler();
 863   3                Tmeperature_Set_Decrease();
 864   3                Tmeperature_Set_Decrease();
 865   3                read_dgus_vp(TEMPERATURE_PRECISION,(u8*)&ii,1);
 866   3                if(ii==0)
 867   3                {
 868   4                  Tmeperature_Set_Decrease();
 869   4                  Tmeperature_Set_Decrease();
 870   4                }
 871   3                Temperature_Set_Confirm_Handler();
 872   3              }
 873   2              yuyin_state[0]=0;
 874   2              yuyin_state[1]=0; 
 875   2            break;
 876   2            case  10:  
 877   2              SpeakCmd[0] = 18;     
 878   2              SpeakCmd[1] = 1;    
 879   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"当前天气"
 880   2              yuyin_state[0]=0;
 881   2              yuyin_state[1]=0; 
 882   2              break;
 883   2            case  11:  
 884   2              SpeakCmd[0] = 9;      
 885   2              SpeakCmd[1] = 1;    
 886   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);    //"开启闹钟"
 887   2              Alarm_Key[0]=1;
 888   2              Alarm_Key[1]=0;
 889   2              write_dgus_vp(ALARM_KEY,(u8*)Alarm_Key,2);
 890   2              yuyin_state[0]=0;
 891   2              yuyin_state[1]=0; 
 892   2            break;
 893   2            case  12:  
 894   2              SpeakCmd[0] = 10;     
 895   2              SpeakCmd[1] = 1;    
 896   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);    //"关闭闹钟"
 897   2              Alarm_Key[0]=0;
 898   2              Alarm_Key[1]=0;
 899   2              write_dgus_vp(ALARM_KEY,(u8*)Alarm_Key,2);
 900   2              yuyin_state[0]=0;
 901   2              yuyin_state[1]=0; 
 902   2            break;
 903   2            case  13:  
 904   2      //              SpeakCmd[0] = 11;     
 905   2      //              SpeakCmd[1] = 1;    
 906   2      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);    //"当前状态"
 907   2            
 908   2              SpeakCmd[0] = 2;      
 909   2              SpeakCmd[1] = 1;    
 910   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"当前温度"
 911   2            
 912   2              yuyin_state[0]=0;
 913   2              yuyin_state[1]=0;   //0202,表示2级菜单，温度降低
 914   2              delay_ms(1000);
 915   2              SpeakCmd[0] = Temperature_Real/100;
 916   2              if(SpeakCmd[0]!=0)
 917   2              {
 918   3                SpeakCmd[0] += 29;
 919   3                SpeakCmd[1] = 1;    
 920   3                write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"温度十位"
 921   3                delay_ms(1000);
 922   3              }
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 16  

 923   2              SpeakCmd[0] = (Temperature_Real%100)/10+ 20;
 924   2              SpeakCmd[1] = 1;    
 925   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"温度个位"
 926   2                delay_ms(1000);
 927   2            
 928   2              SpeakCmd[0] = 14;     
 929   2              SpeakCmd[1] = 1;    
 930   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"当前风速"
 931   2              
 932   2                delay_ms(1700);
 933   2      //                read_dgus_vp(SPEED,(u8*)&Wind_Speed,1);
 934   2              SpeakCmd[0] = Wind_Speed_Val+20;      
 935   2              SpeakCmd[1] = 1;
 936   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2); 
 937   2      //              read_dgus_vp(MODE,(u8*)&Mode,1);
 938   2      //              SpeakCmd[0] =Mode+14;
 939   2      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);    //"模式"
 940   2      //              yuyin_state[0]=0;
 941   2      //              yuyin_state[1]=0; 
 942   2              break;
 943   2            case  14:  
 944   2              SpeakCmd[0] = 8;      
 945   2              SpeakCmd[1] = 1;    
 946   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
 947   2              Wind_Speed--;
 948   2                if(Wind_Speed<1)
 949   2                {
 950   3                  Wind_Speed=1;
 951   3                }
 952   2                write_dgus_vp(SPEED,(u8*)&Wind_Speed,1);
 953   2              yuyin_state[0]=0;
 954   2              yuyin_state[1]=0; 
 955   2                break;
 956   2            case  15:  
 957   2              SpeakCmd[0] = 8;      
 958   2              SpeakCmd[1] = 1;    
 959   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
 960   2              Wind_Speed++;
 961   2                if(Wind_Speed>3)
 962   2                {
 963   3                  Wind_Speed=3;
 964   3                }
 965   2                write_dgus_vp(SPEED,(u8*)&Wind_Speed,1);
 966   2              yuyin_state[0]=0;
 967   2              yuyin_state[1]=0; 
 968   2                break;
 969   2            case  16:   //"降低温度"
 970   2              SpeakCmd[0] = 2;      
 971   2              SpeakCmd[1] = 1;    
 972   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"当前温度"
 973   2            
 974   2              yuyin_state[0]=2;
 975   2              yuyin_state[1]=2;   //0202,表示2级菜单，温度降低
 976   2              delay_ms(1500);
 977   2              SpeakCmd[0] = Temperature_Real/100;
 978   2            if(SpeakCmd[0]!=0)
 979   2            {
 980   3              SpeakCmd[0] += 29;
 981   3              SpeakCmd[1] = 1;    
 982   3              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"温度十位"
 983   3              delay_ms(1500);
 984   3            }
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 17  

 985   2              SpeakCmd[0] = (Temperature_Real%100)/10+ 20;
 986   2              SpeakCmd[1] = 1;    
 987   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"温度个位"
 988   2              
 989   2              delay_ms(1000);
 990   2              SpeakCmd[0] = 40;
 991   2              SpeakCmd[1] = 1;    
 992   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"主人想要多少度"
 993   2              
 994   2              delay_ms(2500);
 995   2              break;
 996   2            case  17:   //"调整一度"
 997   2            case  18:   //"调整两度"
 998   2            case  19:   //"调整三度"
 999   2            case  20:   //"调整四度"
1000   2            case  21:   //"调整五度"
1001   2            case  22:   //"调整六度"
1002   2            case  23:   //"调整七度"
1003   2            case  24:   //"调整八度"
1004   2            case  25:   //"调整九度"
1005   2              
1006   2                write_dgus_vp(0x1110,yuyin_state,1);
1007   2              if((yuyin_state[0]==2)&&(yuyin_state[1]==1))  //增加温度
1008   2              {
1009   3                yuyin_state[0]=0;
1010   3                yuyin_state[1]=0; 
1011   3                read_dgus_vp(SET_TEMP_VALUE,(u8*)&Ttemp,1);
1012   3                Ttemp=Ttemp+dat-16;
1013   3                if(Ttemp>32)
1014   3                {
1015   4                  Ttemp=32;
1016   4                }
1017   3                write_dgus_vp(SET_TEMP_VALUE,(u8*)&Ttemp,1);
1018   3                Ttemp=Ttemp*10;
1019   3                write_dgus_vp(TEMP_SET,(u8*)&Ttemp,1);
1020   3      //              SpeakCmd[0] = 10;     
1021   3      //              SpeakCmd[1] = 1;    
1022   3      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
1023   3              }
1024   2              else if((yuyin_state[0]==2)&&(yuyin_state[1]==2))  //降低温度
1025   2              {
1026   3                yuyin_state[0]=0;
1027   3                yuyin_state[1]=0; 
1028   3                read_dgus_vp(SET_TEMP_VALUE,(u8*)&Ttemp,1);
1029   3                Ttemp=Ttemp-dat+16;
1030   3                if(Ttemp<16)
1031   3                {
1032   4                  Ttemp=16;
1033   4                }
1034   3                write_dgus_vp(SET_TEMP_VALUE,(u8*)&Ttemp,1);
1035   3                Ttemp=Ttemp*10;
1036   3                write_dgus_vp(TEMP_SET,(u8*)&Ttemp,1);
1037   3      //              SpeakCmd[0] = 10;     
1038   3      //              SpeakCmd[1] = 1;    
1039   3      //              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
1040   3              }
1041   2              SpeakCmd[0] = 8;      
1042   2              SpeakCmd[1] = 1;    
1043   2              write_dgus_vp(SPEAK_VP,SpeakCmd,2);   //"已调节设备" 
1044   2              break;
1045   2              default:
1046   2              page_set[0]=0x00;break;
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 18  

1047   2          }
1048   1          
1049   1              write_dgus_vp(PIC_SET,page_set,2);
1050   1              M4G6_ct = 10000;
1051   1      }
1052          void M4G6_dataRx(void)
1053          {
1054   1        u8 *rxp;
1055   1      //  u8  SpeakId;
1056   1      //  u8 *crctst;
1057   1        SpeakCmd[2] = 0x18;
1058   1        SpeakCmd[3] = 0;  
1059   1      //          write_dgus_vp(TEST_VP4,(u8 *)&uart3_rx_count,1);
1060   1        if(uart3_rx_count != 0)
1061   1        {
1062   2      //          write_dgus_vp(TEST_VP4,Uart3_Rx,3);
1063   2          if(Uart3_TTL_Status == 0)
1064   2          {
1065   3            uart3_rx_count = 0;
1066   3            if((Uart3_Rx[0] == 0x5A)&&(Uart3_Rx[1] == 0xA5))
1067   3            {
1068   4              rxp = Uart3_Rx;
1069   4      //          write_dgus_vp(TEST_VP4,Uart3_Rx,3);
1070   4              Calculate_CRC16(rxp,3);
1071   4              Uart3_Rx[0] = 0;
1072   4              Uart3_Rx[1] = 0;
1073   4      //          write_dgus_vp(TEST_VP1,rxp,3);
1074   4              if((rxp[3] == Uart3_Rx[3])&&(rxp[4] == Uart3_Rx[4]))
1075   4              {
1076   5                read_dgus_vp(TEMP_CURRENT,(u8*)&Temperature_Real,1);
1077   5                M4G6_DataDeal(rxp[2]);
1078   5                
1079   5              }
1080   4            }
1081   3          }
1082   2          
1083   2        }
1084   1      }
1085          void Calculate_CRC16(unsigned char *Buff, unsigned int len)
1086          {
1087   1      unsigned int i;
1088   1      unsigned char index,crch,crcl;
1089   1      crch=0xff;
1090   1      crcl=0xff;
1091   1      for(i=0;i<len;i++)
1092   1      {
1093   2      index=crch^Buff[i];
1094   2      crch=crcl^CRCTABH[index];
1095   2      crcl=CRCTABL[index];
1096   2      }
1097   1      Buff[i]=crch;
1098   1      Buff[i+1]=crcl;
1099   1      }
1100          
1101          
1102          
1103          
1104          
1105          
1106          
1107          
1108          
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 19  

1109          
1110          
1111          
1112          
1113          
1114          
1115          
1116          
1117          
1118          
1119          
1120          
1121          
1122          
1123          
1124          
1125          
1126          
1127          
1128          
1129          
1130          
1131          
1132          
1133          
1134          
1135          
1136          
1137          
1138          
1139          
1140          
1141          
1142          
1143          
1144          
1145          
1146          
1147          
1148          
1149          
1150          
1151          
1152          
1153          
1154          
1155          
1156          
1157          
1158          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5420    ----
   CONSTANT SIZE    =    712    ----
   XDATA SIZE       =    195     220
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
C51 COMPILER V9.50a   CONTROL                                                              08/27/2019 16:41:22 PAGE 20  

   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
