C51 COMPILER V9.50a   RTC                                                                  06/20/2019 15:19:47 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE RTC
OBJECT MODULE PLACED IN .\obj\RTC.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE RTC.c LARGE BROWSE INCDIR(..\T5L51) DEBUG OBJECTEXTEND PRINT(.\Listings\RTC
                    -.lst) TABS(2) OBJECT(.\obj\RTC.obj)

line level    source

   1          // #include "reg51.h"
   2          #include "RTC.h"
   3          #include "sys.h"
   4          #include <intrins.h>
   5          sbit SDA=P3^1;                          // 将p3.1口模拟数据口
   6          sbit SCL=P3^0;  
   7          // 将p3.0口模拟时钟口
   8          
   9          #define bus_delay       {u8 bus_ticks = 15; while(bus_ticks--);}
  10          #define Delay_20ticks   {u8 bus_ticks = 20; while(bus_ticks--);}
  11          #define RTC_SCL_OUT      {P3MDOUT|=0x01;  bus_delay;}  
  12          #define RTC_SDA_OUT    {P3MDOUT|= 0x02; bus_delay;}  
  13          #define RTC_SDA_IN       {P3MDOUT&= 0xFD; bus_delay;}  
  14          #define MIN    0x02 //秒寄存器
  15          #define SEC    0x03 //分寄存器
  16          #define HOUR   0x04 //时寄存器
  17          #define DAY    0x05 //日寄存器
  18          #define WEEK   0x06 //周寄存器
  19          #define MONTH 0x07 //月寄存器
  20          #define YEAR   0x08 //年寄存器
  21          #define read_ADD 0xA3 //写器件地址
  22          #define write_ADD 0xA2 //读器件地址
  23          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};                  
  24          unsigned char g8563_Store[4]; /*时间交换区,全局变量声明*/
  25          unsigned char code c8563_Store[4]={0x00,0x59,0x07,0x01}; /*写入时间初值：星期一 07:59:00*/
  26           
  27            u8  ackcheck;
  28          bit   bdata SystemError;                // 从机错误标志位
  29          //--------------------------------------------------------------------------------------------------
  30          // 函数名称： RTC_iic_start()
  31          // 函数功能： 启动I2C总线子程序
  32          //--------------------------------------------------------------------------------------------------
  33          void RTC_iic_start(void)
  34          { RTC_SDA_OUT           //时钟保持高，数据线从高到低一次跳变，I2C通信开始
  35   1        RTC_SCL_OUT
  36   1      SDA = 1;         
  37   1      SCL = 1;
  38   1      bus_delay      // 延时5us 
  39   1      SDA = 0;
  40   1      bus_delay
  41   1      SCL = 0;
  42   1      }
  43          //--------------------------------------------------------------------------------------------------
  44          // 函数名称： RTC_iic_stop()
  45          // 函数功能： 停止I2C总线数据传送子程序
  46          //--------------------------------------------------------------------------------------------------
  47          void RTC_iic_stop(void)
  48          { RTC_SDA_OUT
  49   1      SDA = 0;       //时钟保持高，数据线从低到高一次跳变，I2C通信停止
  50   1      SCL = 1;
  51   1      bus_delay
  52   1      SDA = 1;
  53   1      bus_delay
  54   1      SCL = 0;
C51 COMPILER V9.50a   RTC                                                                  06/20/2019 15:19:47 PAGE 2   

  55   1      }
  56          //--------------------------------------------------------------------------------------------------
  57          // 函数名称： slave_ACK
  58          // 函数功能： 从机发送应答位子程序
  59          //--------------------------------------------------------------------------------------------------
  60          void slave_ACK(void)
  61          {RTC_SDA_OUT
  62   1      SDA = 0;    
  63   1      SCL = 1;
  64   1      bus_delay   
  65   1      SDA = 1;
  66   1      SCL = 0;
  67   1      }
  68          //--------------------------------------------------------------------------------------------------
  69          // 函数名称： slave_NOACK
  70          // 函数功能： 从机发送非应答位子程序，迫使数据传输过程结束
  71          //--------------------------------------------------------------------------------------------------
  72          void slave_NOACK(void)
  73          { RTC_SDA_OUT
  74   1      SDA = 1;   
  75   1      SCL = 1;
  76   1      bus_delay
  77   1      SDA = 0;
  78   1      SCL = 0;
  79   1      }
  80          //--------------------------------------------------------------------------------------------------
  81          // 函数名称： check_ACK
  82          // 函数功能： 主机应答位检查子程序，迫使数据传输过程结束
  83          //--------------------------------------------------------------------------------------------------
  84          void check_ACK(void)
  85          { 
  86   1        u16 timeout = 0;      
  87   1        u8 temp; 
  88   1        SCL = 0;
  89   1        RTC_SDA_IN
  90   1      
  91   1            ackcheck = 1;
  92   1        while(timeout < 255)
  93   1        {
  94   2          timeout++;
  95   2          if(SDA == 0)
  96   2          {ackcheck = 0;
  97   3            break;
  98   3          }
  99   2          else  
 100   2            timeout++;
 101   2        }  
 102   1        SCL = 1;
 103   1        bus_delay
 104   1        SCL = 0;
 105   1        
 106   1        RTC_SDA_OUT
 107   1        SDA = 0;
 108   1      //  bus_delay   
 109   1      //  RTC_SDA_OUTPUTL 
 110   1      // SDA = 1;      // 将p1.0设置成输入，必须先向端口写1
 111   1      // SCL = 1;
 112   1      // RTC_SDA_IN
 113   1      //  for(loopct=0;loopct<20;loopct++)
 114   1      //  {
 115   1      //    if(SDA == 0)    // 若SDA=1表明非应答，置位非应答标志F0
 116   1      //    {
C51 COMPILER V9.50a   RTC                                                                  06/20/2019 15:19:47 PAGE 3   

 117   1      
 118   1      //    SCL = 0;
 119   1      //    return 0;
 120   1      //    }
 121   1      //  }
 122   1      //    return 1;
 123   1      }
*** WARNING C280 IN LINE 87 OF RTC.c: 'temp': unreferenced local variable
 124           
 125          //--------------------------------------------------------------------------------------------------
 126          // 函数名称： IICSendByte
 127          // 入口参数： ch
 128          // 函数功能： 发送一个字节
 129          //--------------------------------------------------------------------------------------------------
 130          void IICSendByte(unsigned char ch)
 131          { 
 132   1      unsigned char idata n=8;     // 向SDA上发送一位数据字节，共八位
 133   1        RTC_SDA_OUT
 134   1      while(n--)
 135   1      { 
 136   2          SCL = 0;
 137   2         if((ch&0x80) == 0x80)    // 若要发送的数据最高位为1则发送位1
 138   2         {
 139   3          SDA = 1;    // 传送位1
 140   3          bus_delay
 141   3          SCL = 1;
 142   3         }
 143   2         else
 144   2         { 
 145   3          SDA = 0;    // 否则传送位0
 146   3          bus_delay
 147   3          SCL = 1;
 148   3         }
 149   2         ch = ch<<1;    // 数据左移一位
 150   2      }
 151   1          SCL = 0;    
 152   1      SDA = 1;
 153   1      }
 154          //--------------------------------------------------------------------------------------------------
 155          // 函数名称： IICreceiveByte
 156          // 返回接收的数据
 157          // 函数功能： 接收一字节子程序
 158          //--------------------------------------------------------------------------------------------------
 159          unsigned char IICreceiveByte(void)
 160          {
 161   1      unsigned char idata n=8;    // 从SDA线上读取一上数据字节，共八位
 162   1      unsigned char tdata;
 163   1        
 164   1         SDA = 1;
 165   1         SCL = 0;
 166   1        RTC_SDA_IN
 167   1      while(n--)
 168   1      {
 169   2         SCL = 1;
 170   2         tdata = tdata<<1;    // 左移一位，或_crol_(temp,1)
 171   2         if(SDA == 1)
 172   2          tdata = tdata|0x01;    // 若接收到的位为1，则数据的最后一位置1
 173   2         else 
 174   2          tdata = tdata&0xfe;    // 否则数据的最后一位置0
 175   2         SCL=0;
 176   2      }
 177   1      
C51 COMPILER V9.50a   RTC                                                                  06/20/2019 15:19:47 PAGE 4   

 178   1         SDA = 0;
 179   1         SCL = 1;
 180   1      return(tdata);
 181   1      }
 182          //--------------------------------------------------------------------------------------------------
 183          // 用户调用子程序
 184          // 函数名称： write_CFGbyte
 185          // 入口参数： CFG_add寄存器地址,CFG_data要写入寄存器的数值
 186          // 函数功能： 发送n位数据子程序
 187          //--------------------------------------------------------------------------------------------------
 188          void write_CFGbyte(unsigned char CFG_add,unsigned char CFG_data)
 189          {          
 190   1      //unsigned char idata send_da,i=0;
 191   1      RTC_iic_start();                // 启动I2C
 192   1      IICSendByte(write_ADD);     // 发送器件写地址
 193   1      check_ACK();                // 检查应答位
 194   1          if(ackcheck == 1)
 195   1      { 
 196   2         SystemError = 1;
 197   2         return;    // 若非应答表明器件错误或已坏，置错误标志位SystemError
 198   2      }
 199   1      IICSendByte(CFG_add);       // 发送寄存器地址
 200   1      check_ACK();                // 检查应答位
 201   1          if(ackcheck == 1)
 202   1      { 
 203   2         SystemError = 1;
 204   2         return;    // 若非应答表明器件错误或已坏，置错误标志位SystemError
 205   2      }
 206   1          IICSendByte(CFG_data);       // 发送寄存器数据
 207   1      check_ACK();                // 检查应答位
 208   1          if(ackcheck == 1)
 209   1      { 
 210   2         SystemError = 1;
 211   2         return;    // 若非应答表明器件错误或已坏，置错误标志位SystemError
 212   2      }
 213   1      RTC_iic_stop();         // 全部发完则停止
 214   1      }
 215          //--------------------------------------------------------------------------------------------------
 216          // 用户调用子程序
 217          // 函数名称： receiveNbyte
 218          // 入口参数： CFG_add寄存器地址地址
 219          // 出口参数： receive_da
 220          // 函数功能： 接收某个寄存器数据子程序
 221          //--------------------------------------------------------------------------------------------------
 222          unsigned char receive_CFGbyte(unsigned char idata CFG_add)
 223          { 
 224   1      unsigned char idata receive_da;
 225   1      //  u8  ackcheck;
 226   1      RTC_iic_start();
 227   1          IICSendByte(write_ADD); //器件写地址
 228   1      check_ACK(); 
 229   1      if(ackcheck == 1)
 230   1      {
 231   2         SystemError = 1;
 232   2         return(0);
 233   2      }
 234   1      IICSendByte(CFG_add); //寄存器地址
 235   1      check_ACK(); 
 236   1      if(ackcheck == 1)
 237   1      {
 238   2         SystemError = 1;
 239   2         return(0);
C51 COMPILER V9.50a   RTC                                                                  06/20/2019 15:19:47 PAGE 5   

 240   2      }
 241   1           RTC_iic_start();
 242   1          IICSendByte(read_ADD); //器件读地址
 243   1         if(ackcheck == 1)
 244   1      {
 245   2         SystemError = 1;
 246   2         return(0);
 247   2      }
 248   1          receive_da=IICreceiveByte();
 249   1         slave_NOACK();       // 收到最后一个字节后发送一个非应答位
 250   1      RTC_iic_stop();
 251   1      return(receive_da);
 252   1      }
 253          //--------------------------------------------------------------------------------------------------
 254          // 用户调用函数
 255          // 函数名称： receive_CFGNbyte
 256          // 入口参数： CFG_add寄存器地址地址，n连续读数位，* buff存储区地址
 257          // 函数功能： 接收n个寄存器数据子程序
 258          //--------------------------------------------------------------------------------------------------
 259          void receive_CFGNbyte(unsigned char CFG_add, unsigned char n,unsigned char * buff)
 260          { 
 261   1      unsigned char receive_da,i=0;
 262   1      //  u8  ackcheck;
 263   1      RTC_iic_start();
 264   1          IICSendByte(write_ADD); //器件写地址
 265   1      check_ACK();
 266   1      if(ackcheck == 1)
 267   1      {
 268   2         SystemError = 1;
 269   2        RTC_iic_stop();
 270   2         return;
 271   2      }
 272   1      IICSendByte(CFG_add); //寄存器地址
 273   1      check_ACK();
 274   1      if(ackcheck == 1)
 275   1      {
 276   2         SystemError = 1;
 277   2        RTC_iic_stop();
 278   2         return;
 279   2      }
 280   1         RTC_iic_start();
 281   1          IICSendByte(read_ADD); //器件读地址
 282   1         if(ackcheck == 1)
 283   1      {
 284   2         SystemError = 1;
 285   2        RTC_iic_stop();
 286   2         return;
 287   2      }
 288   1      while(n--)
 289   1      { 
 290   2         receive_da=IICreceiveByte();
 291   2         buff[i++]=receive_da;
 292   2         slave_ACK();    // 收到一个字节后发送一个应答位
 293   2      }
 294   1      slave_NOACK();    // 收到最后一个字节后发送一个非应答位
 295   1      RTC_iic_stop();
 296   1      }
 297          //--------------------------------------------------------------------------------------------------
 298          // 用户调用函数
 299          // 函数名称： P8563_Readtime
 300          // 函数功能： 读出时间信息
 301          //--------------------------------------------------------------------------------------------------
C51 COMPILER V9.50a   RTC                                                                  06/20/2019 15:19:47 PAGE 6   

 302          void P8563_Readtime()
 303          {   unsigned char time[7];
 304   1          receive_CFGNbyte(MIN,0x07,time);
 305   1          g8563_Store[0]=time[0]&0x7f; /*秒*/
 306   1          g8563_Store[1]=time[1]&0x7f; /*分*/
 307   1          g8563_Store[2]=time[2]&0x3f; /*小时*/
 308   1          g8563_Store[3]=time[4]&0x07; /*星期*/
 309   1      }
 310          //--------------------------------------------------------------------------------------------------
 311          // 用户调用函数
 312          // 函数名称： P8563_settime
 313          // 函数功能： 写时间修改值
 314          //--------------------------------------------------------------------------------------------------
 315          void P8563_settime()
 316          {
 317   1           unsigned char i;
 318   1           for(i=2;i<=4;i++) { write_CFGbyte(i,g8563_Store[i-2]); }
 319   1           write_CFGbyte(6,g8563_Store[3]);
 320   1      }
 321          //--------------------------------------------------------------------------------------------------
 322          // 用户调用函数
 323          // 函数名称： P8563_init
 324          // 函数功能： 初始设置
 325          //--------------------------------------------------------------------------------------------------
 326          void P8563_init()
 327          {
 328   1          unsigned char i;
 329   1        RTC_SCL_OUT
 330   1        RTC_SDA_OUT
 331   1          if((receive_CFGbyte(0x0a))!=0x8) /*检查是否第一次启动，是则初始化时间*/
 332   1          {
 333   2              for(i=0;i<=3;i++) 
 334   2         g8563_Store[i]=c8563_Store[i]; /*初始化时间*/
 335   2              P8563_settime();
 336   2              write_CFGbyte(0x0,0x00);
 337   2              write_CFGbyte(0xa,0x8); /*8:00报警*/
 338   2              write_CFGbyte(0x01,0x12); /*报警有效*/
 339   2              write_CFGbyte(0xd,0xf0);
 340   2          }
 341   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    936    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =      5      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----       3
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
