C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 1   


C51 COMPILER V9.50a, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\obj\timer.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE timer.c LARGE OBJECTADVANCED BROWSE INCDIR(..\T5L51) DEBUG PRINT(.\Listings
                    -\timer.lst) TABS(2) OBJECT(.\obj\timer.obj)

line level    source

   1          #include "timer.h"
   2          #include "sys.h"
   3          
   4          // rtc_time real_time;
   5          u8 RTC_fault;
   6          u8 data date_time[7]={0};     //存放RTC时钟，date_time[7]={年，月，日，周，时，分，秒}
   7          /**************************************************************
   8                          hextoBCD
   9          
  10          函数功能: 把给定字节按16进制转换成BCD码格式
  11          参数:   number-待转换的字节
  12          返回值:   data-转换后的字节
  13          **************************************************************/
  14          u8 hextobcd(u8 number)
  15          {
  16   1        u8 hex; 
  17   1      
  18   1        hex = number / 10;
  19   1        hex = hex << 4;  
  20   1        number = number % 10;
  21   1        hex = hex | number; 
  22   1        return(hex);                
  23   1      }
  24          
  25          /**************************************************************
  26          *                  BCDtohex
  27          
  28          函数功能: 把给定字节按BCD码转换成16进制格式
  29          参数:   number-待转换的字节
  30          返回值:   data-转换后的字节
  31          
  32          **************************************************************/
  33          u8 bcdtohex(u8 number)
  34          {
  35   1         u8 bcd;  
  36   1         
  37   1         bcd = number & 0xf0;
  38   1         bcd = bcd >> 4;                                                        
  39   1      
  40   1         bcd = bcd * 0x0a;
  41   1         number = number & 0x0f;
  42   1         bcd = bcd + number;
  43   1         return(bcd); 
  44   1      } 
  45          /*********************************************************************************************************
             -**************************
  46                        I2C驱动函数定义区
  47          **********************************************************************************************************
             -**************************/
  48          
  49          /**************************************************************
  50                I2C串口开始条件
  51          **************************************************************/
  52          
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 2   

  53          
  54          void RTC_Start(void)
  55          {   
  56   1        RTC_SDA_OUT
  57   1        RTC_SDA_OUTPUTL
  58   1      
  59   1          
  60   1        RTC_SCL_OUT
  61   1        bus_delay
  62   1        RTC_SCL_OUTPUTL 
  63   1        
  64   1      
  65   1        RTC_SDA_OUTPUTL  
  66   1        RTC_SDA_OUTPUTH
  67   1      
  68   1        RTC_SCL_OUTPUTH
  69   1        RTC_SDA_OUTPUTL
  70   1        RTC_SCL_OUTPUTL
  71   1      }
  72          
  73          /**************************************************************
  74                I2C串口结束条件
  75          **************************************************************/
  76          void RTC_Stop(void)
  77          { 
  78   1      
  79   1        RTC_SCL_OUTPUTL
  80   1        RTC_SDA_OUTPUTL
  81   1      
  82   1        RTC_SCL_OUTPUTH    
  83   1        RTC_SDA_OUTPUTH
  84   1        RTC_SCL_OUTPUTL   
  85   1        RTC_SDA_OUTPUTL 
  86   1        
  87   1      }
  88          
  89          /**************************************************************
  90                I2C串口发送一个字节
  91          
  92          函数功能: I2C串口发送一个字节
  93          参数:   Byte-发送的字节
  94          返回值:   无
  95          **************************************************************/
  96          void RTC_Send_Byte(u8 Byte)
  97          {
  98   1        u8 i;
  99   1        
 100   1        RTC_SCL_OUTPUTL   
 101   1        RTC_SDA_OUTPUTL 
 102   1        for (i=0; i<8; i++)
 103   1        {
 104   2          if(Byte & 0x80)  // first MSB
 105   2          {
 106   3            RTC_SDA_OUTPUTH
 107   3          }
 108   2          else
 109   2          { 
 110   3            RTC_SDA_OUTPUTL
 111   3          }    
 112   2          RTC_SCL_OUTPUTH
 113   2          RTC_SCL_OUTPUTL    
 114   2          Byte = Byte << 1;
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 3   

 115   2        } 
 116   1      }
 117          
 118          /**************************************************************
 119                I2C串口接收等待回复
 120          
 121          函数功能: I2C串口接收等待回复
 122          参数:   无
 123          返回值:   无
 124          **************************************************************/
 125          void RTC_Ack(void) 
 126          { 
 127   1        u16 timeout = 0;      
 128   1        u8 temp; 
 129   1      
 130   1        RTC_SCL_OUTPUTL
 131   1        RTC_SDA_IN
 132   1      
 133   1        while(timeout < 255)
 134   1        {
 135   2          timeout++;
 136   2          temp = RTC_SDADATA_PORT;
 137   2          if(temp == 0)
 138   2            break;
 139   2          else  
 140   2            timeout++;
 141   2        }  
 142   1      
 143   1        RTC_SCL_OUTPUTH       
 144   1        RTC_SCL_OUTPUTL  
 145   1      
 146   1        bus_delay   
 147   1        RTC_SDA_OUTPUTL 
 148   1      }
 149          
 150          /**************************************************************
 151                I2C串口发送回复
 152          
 153          函数功能: I2C串口发送回复
 154          参数:   无
 155          返回值:   无
 156          **************************************************************/
 157          void RTC_Send_Ack(void) 
 158          {      
 159   1        RTC_SCL_OUTPUTL  
 160   1        bus_delay 
 161   1        RTC_SDA_OUTPUTL 
 162   1      
 163   1        RTC_SCL_OUTPUTH  
 164   1        RTC_SCL_OUTPUTL  
 165   1        RTC_SDA_IN
 166   1      }
 167          
 168          
 169          /**************************************************************
 170                I2C串口发送无回复
 171          
 172          函数功能: I2C串口发送无回复
 173          参数:   无
 174          返回值:   无
 175          **************************************************************/
 176          void RTC_NOAck(void)
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 4   

 177          {
 178   1        RTC_SDA_IN  
 179   1        RTC_SCL_OUTPUTH
 180   1        RTC_SCL_OUTPUTL
 181   1      
 182   1        bus_delay
 183   1        RTC_SDA_OUTPUTL 
 184   1      }
 185          
 186          /**************************************************************
 187                I2C串口接收一个字节
 188          
 189          函数功能: I2C串口接收一个字节
 190          参数:   无
 191          返回值:   R_word-接收到的字节
 192          
 193          **************************************************************/
 194          u8  RTC_Receive_Byte(void)
 195          {
 196   1        u8 R_word; 
 197   1        u8 j;
 198   1        u8 temp;
 199   1      
 200   1        R_word = 0x00;
 201   1        RTC_SDA_IN
 202   1      
 203   1        for(j=0; j<8; j++)
 204   1        {       
 205   2          
 206   2          RTC_SCL_OUTPUTH
 207   2          temp = RTC_SDADATA_PORT;
 208   2      
 209   2          R_word = R_word << 1;
 210   2          if(temp != 0) // first MSB
 211   2          { 
 212   3            R_word |= 0x01; 
 213   3          }
 214   2          else
 215   2          { 
 216   3            R_word &= 0xfe; 
 217   3          }
 218   2          Delay_20ticks;
 219   2      
 220   2          RTC_SCL_OUTPUTL            
 221   2        }  
 222   1      
 223   1        return(R_word);
 224   1      }
 225          /**************************************************************
 226                RTC时钟写入函数
 227          
 228          函数功能: RTC时钟写入
 229          参数:   W_addr-写入地址，默认2，无特殊要求不要修改
 230                *word-写入的时钟数组，即date_time[7]={年，月，日，周，时，分，秒}
 231          返回值:   无
 232          
 233          **************************************************************/
 234          u8 last_hour = 0;     //记录小时计数发生变化时的上一次小时数
 235          u8 urtc_hourcnt = 0;      //允许校准时，对小时进行计数
 236          
 237          void I2C_RTC_Write(u8 W_addr, u8 *word)
 238          {   
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 5   

 239   1          u8 number;
 240   1          u8 i;
 241   1          u8 rtc_temp; 
 242   1        
 243   1          switch(W_addr)
 244   1          {
 245   2              case 0:
 246   2              case 1: 
 247   2              case 6: 
 248   2              case 7: number = 1; break;
 249   2              case 2: number = 7; break;
 250   2              case 3: number = 3; break;
 251   2              case 4:
 252   2              case 5: number = 4; break;
 253   2          }
 254   1        
 255   1          RTC_Start();
 256   1        
 257   1          RTC_Send_Byte(0xA2);
 258   1          RTC_Ack();
 259   1          
 260   1          RTC_Send_Byte(W_addr);
 261   1          RTC_Ack();  
 262   1        
 263   1          for(i=0; i<number; i++)
 264   1          {
 265   2              rtc_temp = hextobcd(*(word++));
 266   2              RTC_Send_Byte(rtc_temp);
 267   2              RTC_Ack();
 268   2          }  
 269   1          RTC_Stop();
 270   1        
 271   1        
 272   1          last_hour = date_time[4];
 273   1          urtc_hourcnt = 0;
 274   1      }
 275          /**************************************************************
 276                RTC时钟读取函数
 277          
 278          函数功能: RTC时钟读出
 279          参数:   R_addr-写入地址，默认2，无特殊要求不要修改
 280                *RTC_buffer-读取的时钟数组，即date_time[7]={年，月，日，周，时，分，秒}
 281          返回值:   无
 282          
 283          **************************************************************/
 284          void I2C_RTC_Read(u8 R_addr, u8 *RTC_buffer)
 285          { 
 286   1          u8 rtc_temp; 
 287   1          u8 number;
 288   1          u8 i;
 289   1          
 290   1          switch(R_addr)
 291   1          {
 292   2              case 0:
 293   2              case 1: 
 294   2              case 6: 
 295   2              case 7: number=1; break;
 296   2              case 2: number=7; break;
 297   2              case 3: number=3; break;
 298   2              case 4:
 299   2              case 5: number=4; break;
 300   2          }
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 6   

 301   1        
 302   1        
 303   1          RTC_Start();   
 304   1        
 305   1          RTC_Send_Byte(0xA2);
 306   1          RTC_Ack();
 307   1          
 308   1          RTC_Send_Byte(R_addr);
 309   1          RTC_Ack();
 310   1        
 311   1          RTC_Start();   
 312   1          
 313   1          RTC_Send_Byte(0xA3);
 314   1          RTC_Ack();
 315   1          
 316   1          for(i=0; i<(number-1); i++)
 317   1          {
 318   2              rtc_temp = RTC_Receive_Byte(); 
 319   2               
 320   2              if((i == 0)||(i == 1))    
 321   2              {              
 322   3                rtc_temp = rtc_temp & 0x7f;
 323   3              }
 324   2              if((i == 2)||(i == 3))    
 325   2              {              
 326   3                rtc_temp = rtc_temp & 0x3f;
 327   3              }
 328   2              if(i == 4)   
 329   2              {              
 330   3                rtc_temp = rtc_temp & 0x07;
 331   3              }
 332   2              if(i == 5)    
 333   2              {              
 334   3                rtc_temp = rtc_temp & 0x1f;
 335   3              }
 336   2              rtc_temp = bcdtohex(rtc_temp);  
 337   2              RTC_buffer[i] = rtc_temp;
 338   2          
 339   2              RTC_Send_Ack();
 340   2          }
 341   1        
 342   1          rtc_temp = RTC_Receive_Byte();
 343   1          rtc_temp = rtc_temp&0x7f;
 344   1          rtc_temp = bcdtohex(rtc_temp);  
 345   1          RTC_buffer[i] = rtc_temp;
 346   1          RTC_NOAck();
 347   1        
 348   1          RTC_Stop();  
 349   1      }
 350          /**************************************************************
 351                RTC时钟初始化函数
 352          
 353          函数功能: RTC时钟状态初始化
 354          参数:   无
 355          返回值:   无
 356          
 357          *************************************************************/
 358          void RTC_init(void)
 359          {
 360   1        u8 dat;    
 361   1      
 362   1        dat = 0x20;
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 7   

 363   1        I2C_RTC_Write(0x00,&dat);
 364   1        delay_ms(10);
 365   1        
 366   1        dat = 0x00;
 367   1        I2C_RTC_Write(0x00,&dat);
 368   1        delay_ms(10);
 369   1      } 
 370          
 371          /**************************************************************
 372                RTC时钟运行函数
 373          
 374          函数功能: RTC时钟运行时调用此函数，必须放在1秒任务中
 375          参数:   srtc_caltype-时钟校准类型:  RTCCAL_ADDTIME  1 //加时间校准，即时间走的慢
 376                              RTCCAL_NONEED 0 //不需要时间校准
 377                              RTCCAL_MINTIME  -1  //减时间校准，即时间走的快
 378                urtc_calval-校准值，即走快(慢)1秒所需要的时间(小时) 数            
 379          返回值:   无
 380          
 381          **************************************************************/
 382          void RTC_RunFunction(void)
 383          {
 384   1          I2C_RTC_Read(0x02, date_time); 
 385   1          if(date_time[1] > 60)   //
 386   1          {
 387   2              date_time[6] = 20;//年
 388   2              date_time[5] = 5; //月
 389   2              date_time[4] = 5;//星期
 390   2              date_time[3] = 31;//日
 391   2              date_time[2] = 16;//时
 392   2              date_time[1] = 14;//分
 393   2              date_time[0] = 14;//秒
 394   2              I2C_RTC_Write(0x02, date_time);
 395   2            delay_ms(10);
 396   2              I2C_RTC_Read(0x02, date_time); 
 397   2          }
 398   1        
 399   1      
 400   1          if(date_time[5] == 0 || date_time[3] == 0 || date_time[5] > 12 || date_time[3] > 31)
 401   1            RTC_fault = 1;
 402   1          else
 403   1            RTC_fault = 0;
 404   1      }
 405          void RTC_Reset(u8* buf)
 406          {
 407   1        u8  datetime_set[7]={0};
 408   1        if((*buf++==0x5A)&&(*buf++==0xA5))
 409   1        {
 410   2          datetime_set[6]=*buf++;
 411   2          datetime_set[5]=*buf++;
 412   2          datetime_set[3]=*buf++;
 413   2          datetime_set[4] = -35 + datetime_set[6] + (datetime_set[6]/4) + (26*(datetime_set[5]+1)/10)+datetime_set
             -[3]-1;
 414   2          datetime_set[4] = datetime_set[4]%7;
 415   2          if(datetime_set[4] < 0) datetime_set[4]+=7;
 416   2          datetime_set[2]=*buf++;
 417   2          datetime_set[1]=*buf++;
 418   2          datetime_set[0]=0;
 419   2          I2C_RTC_Write(0x02, datetime_set);
 420   2          
 421   2        }
 422   1      }
 423          /*****************************************************************************
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 8   

 424           函 数 名  : void Time_Update(void)
 425           功能描述  : 更新时间
 426           输入参数  :   
 427           输出参数  : 
 428           修改历史  :
 429            1.日    期   : 2019年4月2日
 430              作    者   : chengjing
 431              修改内容   : 创建
 432          *****************************************************************************/
 433          void Time_Update(void)
 434          {
 435   1          u16 RTC_Hour_D,RTC_Min_D;
 436   1          RTC_RunFunction();
 437   1          real_time.year=date_time[6];  
 438   1          real_time.month=date_time[5]; 
 439   1          real_time.week=date_time[4];  
 440   1          real_time.day=date_time[3]; 
 441   1          real_time.hour=date_time[2];  
 442   1          real_time.min=date_time[1]; 
 443   1          real_time.sec=date_time[0]; 
 444   1          
 445   1      //    real_time.year=19;  
 446   1      //    real_time.month=6;  
 447   1      //    real_time.week=13;  
 448   1      //    real_time.day=4;  
 449   1      //    real_time.hour=16;  
 450   1      //    real_time.min=10; 
 451   1      //    real_time.sec=0;  
 452   1        
 453   1      //  if(Second_Updata_Flag==1)
 454   1      //  {
 455   1      //    real_time.week=RTC_Get_Week(real_time.year,real_time.month,real_time.day);  
 456   1      //    write_dgus_vp(RTC,(u8*)&real_time.year,4);  
 457   1      //    time_display[0]=real_time.year+2000;
 458   1      //    time_display[1]=real_time.month+100;;
 459   1      //    time_display[2]=real_time.day+100;
 460   1      //    time_display[3]=real_time.week;   //0-6表示星期一到星期日
 461   1      //    time_display[4]=real_time.hour+100;
 462   1      //    time_display[5]=real_time.min+100;
 463   1      //    time_display[6]=real_time.sec+100;
 464   1      //    write_dgus_vp(TIME_DISPLAY,(u8*)time_display,7);    
 465   1      //    Second_Updata_Flag=0;
 466   1      //    Time_Calibration(); 
 467   1      //    read_dgus_vp(RTC,(u8*)&real_time.year,4);
 468   1        
 469   1          real_time.week=RTC_Get_Week(real_time.year,real_time.month,real_time.day);  
 470   1          write_dgus_vp(RTC,(u8*)&real_time.year,4);
 471   1          RTC_Hour_D=real_time.hour+100;
 472   1          RTC_Min_D=real_time.min+100;
 473   1          write_dgus_vp(TIME_HOUR_DISPLAY,(u8*)&RTC_Hour_D,1);
 474   1          write_dgus_vp(TIME_MIN_DISPLAY,(u8*)&RTC_Min_D,1);
 475   1          
 476   1          time_display[0]=real_time.year+2000;
 477   1          time_display[1]=real_time.month+100;;
 478   1          time_display[2]=real_time.day+100;
 479   1          time_display[3]=real_time.week;   //0-6表示星期一到星期日
 480   1          time_display[4]=real_time.hour+100;
 481   1          time_display[5]=real_time.min+100;
 482   1          time_display[6]=real_time.sec+100;
 483   1          write_dgus_vp(TIME_DISPLAY,(u8*)time_display,7);  
 484   1      }
 485          
C51 COMPILER V9.50a   TIMER                                                                08/27/2019 16:41:23 PAGE 9   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2299    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =      3      31
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
