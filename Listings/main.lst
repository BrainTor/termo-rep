C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "T5LOS8051.h"
   2          
   3          /* ---------------------------------------------------------------
   4           * –¢–∏–ø—ã
   5           * ------------------------------------------------------------- */
   6          
   7          typedef unsigned char  u8;
   8          typedef unsigned short u16;
   9          typedef signed   short s16;
  10          typedef unsigned long  u32;
  11          typedef signed   long  s32;
  12          
  13          /* ---------------------------------------------------------------
  14           * –ê–¥—Ä–µ—Å–∞ VP (—Ä–µ–≥–∏—Å—Ç—Ä—ã –∏–∑ –¢–ó) –∏ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∞–¥—Ä–µ—Å–∞ DGUS
  15           * ------------------------------------------------------------- */
  16          
  17          /* –î–∞—Ç–∞/–≤—Ä–µ–º—è */
  18          #define VP_YEAR        0x2010
  19          #define VP_MONTH       0x2011
  20          #define VP_DAY         0x2012
  21          #define VP_WEEKDAY     0x2013
  22          #define VP_HOUR        0x2014
  23          #define VP_MIN         0x2015
  24          #define VP_SEC         0x2016
  25          
  26          /* –°–∏—Å—Ç–µ–º–Ω—ã–π RTC DGUS */
  27          #define OS_RTC         0x0010
  28          
  29          /* –ì—Ä–∞—Ñ–∏–∫ 1 */
  30          #define VP_G1_STATUS   0x2020
  31          #define VP_G1_DAYS     0x2021
  32          #define VP_G1_SPEED    0x2022
  33          #define VP_G1_TEMP     0x2023
  34          #define VP_G1_SHOUR    0x2024
  35          #define VP_G1_SMIN     0x2025
  36          #define VP_G1_EHOUR    0x2026
  37          #define VP_G1_EMIN     0x2027
  38          
  39          /* –ì—Ä–∞—Ñ–∏–∫ 2 */
  40          #define VP_G2_STATUS   0x2030
  41          #define VP_G2_DAYS     0x2031
  42          #define VP_G2_SPEED    0x2032
  43          #define VP_G2_TEMP     0x2033
  44          #define VP_G2_SHOUR    0x2034
  45          #define VP_G2_SMIN     0x2035
  46          #define VP_G2_EHOUR    0x2036
  47          #define VP_G2_EMIN     0x2037
  48          
  49          /* –ì—Ä–∞—Ñ–∏–∫ 3 */
  50          #define VP_G3_STATUS   0x2040
  51          #define VP_G3_DAYS     0x2041
  52          #define VP_G3_SPEED    0x2042
  53          #define VP_G3_TEMP     0x2043
  54          #define VP_G3_SHOUR    0x2044
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 2   

  55          #define VP_G3_SMIN     0x2045
  56          #define VP_G3_EHOUR    0x2046
  57          #define VP_G3_EMIN     0x2047
  58          
  59          /* –ì—Ä–∞—Ñ–∏–∫ 4 */
  60          #define VP_G4_STATUS   0x2050
  61          #define VP_G4_DAYS     0x2051
  62          #define VP_G4_SPEED    0x2052
  63          #define VP_G4_TEMP     0x2053
  64          #define VP_G4_SHOUR    0x2054
  65          #define VP_G4_SMIN     0x2055
  66          #define VP_G4_EHOUR    0x2056
  67          #define VP_G4_EMIN     0x2057
  68          
  69          /* –û—Å–Ω–æ–≤–Ω—ã–µ —Ä–µ–≥–∏—Å—Ç—Ä—ã —Ä–∞–±–æ—Ç—ã */
  70          #define VP_ONOFF       0x2060   /* 1 ‚Äì –≤—ã–∫–ª, 2 ‚Äì –≤–∫–ª */
  71          #define VP_SPEED       0x2061   /* 1..4 */
  72          #define VP_MODE        0x2062   /* 1 ‚Äì –æ—Ö–ª, 2 ‚Äì –Ω–∞–≥—Ä–µ–≤ */
  73          #define VP_T_REAL_10X  0x2063   /* *10 */
  74          #define VP_T_REAL_INT  0x2064
  75          #define VP_T_SET_10X   0x2065   /* *10 */
  76          #define VP_T_SET_INT   0x2066
  77          #define VP_GRAPH_EN    0x2067
  78          
  79          /* –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Modbus */
  80          #define VP_MB_ADDR     0x2070   /* 1..247 */
  81          #define VP_MB_SPEED    0x2071   /* 1..7 */
  82          #define VP_MB_PROTO    0x2072   /* 1..6 */
  83          
  84          /* –°–∏—Å—Ç–µ–º–Ω—ã–π –ê–¶–ü */
  85          #define OS_AD_VALUE    0x0032
  86          
  87          /* –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã (–∫–∞–∫ –≤ tttt) */
  88          #define VP_T_COEF       0x2550   /* 3 —Å–ª–æ–≤–∞: K1, K2, C */
  89          #define VP_T_PRECISION  0x2554   /* 0 ‚Äì 0.5¬∞C, 1 ‚Äì 1.0¬∞C */
  90          
  91          /* ---------------------------------------------------------------
  92           * –ê–ø–ø–∞—Ä–∞—Ç–Ω—ã–µ –ª–∏–Ω–∏–∏
  93           * ------------------------------------------------------------- */
  94          
  95          sbit RELAY_VALVE = P1^3;
  96          sbit RELAY_LOW   = P1^1;
  97          sbit RELAY_HIGH  = P1^2;
  98          sbit RELAY_MID   = P1^4;
  99          sbit RS485_DE = P0^1;   /* –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º RS485 (P0.1 = TR5) */
 100          sbit TX2_SEL  = P0^4;   /* –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å TX –Ω–∞ –ø–ª–∞—Ç–µ */
 101          sbit TR4_PIN  = P0^0;   /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –ø–∏–Ω —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
 102          
 103          #define RELAY_VALVE_BIT  (1u << 3)
 104          #define RELAY_LOW_BIT    (1u << 1)
 105          #define RELAY_HIGH_BIT   (1u << 2)
 106          #define RELAY_MID_BIT    (1u << 4)
 107          
 108          /* ---------------------------------------------------------------
 109           * –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
 110           * ------------------------------------------------------------- */
 111          
 112          #define TEMP_HYST_10X 10
 113          #define NTC_TABLE_SIZE 100
 114          #define FOSC     206438400UL
 115          #define T1MS     (65536UL - FOSC/12UL/1000UL)
 116          
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 3   

 117          /* Modbus */
 118          #define MODBUS_RX_BUF_SIZE 64
 119          #define MODBUS_TX_BUF_SIZE 64
 120          #define MODBUS_TIMEOUT_MS  25   /* —Ç–∞–π–º–∞—É—Ç –º–µ–∂–¥—É –±–∞–π—Ç–∞–º–∏ (–∫–∞–∫ –≤ —Ä–∞–±–æ—á–µ–º –∫–æ
             -–¥–µ) */
 121          
 122          /* –î–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏–µ VP –∞–¥—Ä–µ—Å–∞ */
 123          #define VP_DIAG_RX_CNT    0x2080   /* –°—á—ë—Ç—á–∏–∫ –ø—Ä–∏–Ω—è—Ç—ã—Ö –±–∞–π—Ç */
 124          #define VP_DIAG_FRAME_OK  0x2081   /* –£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –∫–∞–¥—Ä–æ–≤ */
 125          #define VP_DIAG_CRC_ERR   0x2082   /* –û—à–∏–±–æ–∫ CRC */
 126          #define VP_DIAG_ADDR_ERR  0x2083   /* –û—à–∏–±–æ–∫ –∞–¥—Ä–µ—Å–∞ */
 127          
 128          /* Modbus —Ñ—É–Ω–∫—Ü–∏–∏ */
 129          #define MB_FUNC_READ_REGS      0x03
 130          #define MB_FUNC_WRITE_REG      0x06
 131          #define MB_FUNC_WRITE_REGS     0x10
 132          
 133          /* Modbus –æ—à–∏–±–∫–∏ */
 134          #define MB_ERR_ILLEGAL_FUNC    0x01
 135          #define MB_ERR_ILLEGAL_ADDR    0x02
 136          #define MB_ERR_ILLEGAL_VALUE   0x03
 137          
 138          /* ---------------------------------------------------------------
 139           * –¢–∞–±–ª–∏—Ü—ã NTC
 140           * ------------------------------------------------------------- */
 141          
 142          static const u16 code NTC1_TABLE[NTC_TABLE_SIZE] =
 143          {
 144              32040,30490,29022,27633,26317,25071,23889,22769,21707,20700,
 145              19788,18838,17977,17160,16383,15646,14945,14280,13647,13045,
 146              12472,11928,11409,10916,10447,10000, 9574, 9168, 8781, 8413,
 147               8062, 7727, 7407, 7103, 6812, 6534, 6270, 6017, 5775, 5545,
 148               5324, 5114, 4913, 4720, 4536, 4360, 4192, 4031, 3877, 3730,
 149               3572, 3454, 3324, 3201, 3082, 2968, 2859, 2755, 2654, 2558,
 150               2466, 2378, 2293, 2212, 2134, 2059, 1987, 1918, 1851, 1788,
 151               1726, 1668, 1611, 1557, 1504, 1454, 1406, 1359, 1314, 1271,
 152               1230, 1190, 1151, 1114, 1079, 1045, 1011,  980,  949,  919,
 153                891,  863,  837,  811,  786,  763,  740,  718,  696,  675
 154          };
 155          
 156          static const u16 code NTC2_TABLE[NTC_TABLE_SIZE] =
 157          {
 158              32800,31141,29572,28090,26690,25366,24116,22935,21820,20767,
 159              19773,18835,17949,17113,16323,15578,14874,14208,13579,12983,
 160              12419,11885,11378,10896,10437,10000, 9513, 9064, 8649, 8263,
 161               7904, 7570, 7256, 6960, 6682, 6420, 6170, 5932, 5707, 5491,
 162               5284, 5085, 4895, 4712, 4536, 4367, 4204, 4047, 3896, 3750,
 163               3610, 3475, 3346, 3221, 3101, 2987, 2876, 2771, 2670, 2573,
 164               2480, 2391, 2307, 2226, 2148, 2074, 2004, 1936, 1871, 1809,
 165               1750, 1693, 1586, 1535, 1486, 1439, 1393, 1348, 1305, 1262,
 166               1220, 1178, 1137, 1097, 1056, 1023,  991,  960,  931,  903,
 167                876,  850,  825,  801,  777,  755,  733,  713,  692,  673
 168          };
 169          
 170          static const u8 code table_week[12] = {0,3,3,6,1,4,6,2,5,0,3,5};
 171          static const u8 code mon_table[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
 172          
 173          /* –¢–∞–±–ª–∏—Ü–∞ CRC16 Modbus (High byte) */
 174          static const u8 code CRC_HI[] = {
 175              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 176              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 177              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 4   

 178              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 179              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 180              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 181              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 182              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 183              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 184              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 185              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 186              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 187              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
 188              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 189              0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
 190              0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40
 191          };
 192          
 193          /* –¢–∞–±–ª–∏—Ü–∞ CRC16 Modbus (Low byte) */
 194          static const u8 code CRC_LO[] = {
 195              0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,0x04,
 196              0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,0x08,0xC8,
 197              0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,0x1D,0x1C,0xDC,
 198              0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,0x11,0xD1,0xD0,0x10,
 199              0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,0x37,0xF5,0x35,0x34,0xF4,
 200              0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,0x3B,0xFB,0x39,0xF9,0xF8,0x38,
 201              0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,
 202              0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,
 203              0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,
 204              0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,
 205              0x78,0xB8,0xB9,0x79,0xBB,0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,
 206              0xB4,0x74,0x75,0xB5,0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,
 207              0x50,0x90,0x91,0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,
 208              0x9C,0x5C,0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,
 209              0x88,0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
 210              0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,0x40
 211          };
 212          
 213          /* ---------------------------------------------------------------
 214           * –°—Ç—Ä—É–∫—Ç—É—Ä—ã
 215           * ------------------------------------------------------------- */
 216          
 217          typedef struct
 218          {
 219              u8  year;
 220              u8  month;
 221              u8  day;
 222              u8  weekday;
 223              u8  hour;
 224              u8  min;
 225              u8  sec;
 226          } RtcTime;
 227          
 228          typedef struct
 229          {
 230              u8  active;
 231              u8  prev_speed;
 232              u16 prev_t_set;
 233          } GraphRuntime;
 234          
 235          typedef struct
 236          {
 237              u8  status;
 238              u8  days;
 239              u8  speed;
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 5   

 240              u8  temp_int;
 241              u8  shour;
 242              u8  smin;
 243              u8  ehour;
 244              u8  emin;
 245          } GraphConfig;
 246          
 247          /* ---------------------------------------------------------------
 248           * –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
 249           * ------------------------------------------------------------- */
 250          
 251          static RtcTime      g_rtc = {25, 1, 25, 6, 0, 0, 0}; /* –≥–æ–¥=25 (2025), –º–µ—Å—è—Ü=1, –¥–µ–Ω—å=25, —Å—É–
             -±–±–æ—Ç–∞ */
 252          static u16   data   SysTick       = 0;
 253          static u16   data   SysTick_RTC   = 0;
 254          static bit          g_rtc_1s_flag = 0;
 255          
 256          static u8           g_onoff   = 2;
 257          static u8           g_speed   = 1;
 258          static u8           g_mode    = 2;
 259          static u16          g_t_set_10x  = 220;
 260          static u16          g_t_real_10x = 220;
 261          static bit          g_valve_open = 1;
 262          static u8           g_graph_en   = 1;
 263          
 264          static GraphConfig  g_graph_cfg[4];
 265          static GraphRuntime g_graph_rt[4];
 266          
 267          
 268          /* Modbus */
 269          static u8           g_mb_addr = 247;    /* –ê–¥—Ä–µ—Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ */
 270          static u8           g_mb_speed_idx = 7; /* –ò–Ω–¥–µ–∫—Å —Å–∫–æ—Ä–æ—Å—Ç–∏ (7=115200) */
 271          static u8           g_mb_proto = 1;     /* –ü—Ä–æ—Ç–æ–∫–æ–ª (1=8N1) */
 272          
 273          static u8  xdata    g_mb_rx_buf[MODBUS_RX_BUF_SIZE];
 274          static u8           g_mb_rx_cnt = 0;
 275          static u8  xdata    g_mb_tx_buf[MODBUS_TX_BUF_SIZE];
 276          static u8           g_mb_rx_timeout = 0;
 277          static bit          g_mb_frame_ready = 0;
 278          
 279          /* –î–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–∏–µ —Å—á—ë—Ç—á–∏–∫–∏ */
 280          static u16          g_diag_rx_total = 0;    /* –í—Å–µ–≥–æ –ø—Ä–∏–Ω—è—Ç–æ –±–∞–π—Ç */
 281          static u16          g_diag_frame_ok = 0;    /* –£—Å–ø–µ—à–Ω—ã—Ö –∫–∞–¥—Ä–æ–≤ */
 282          static u16          g_diag_crc_err = 0;     /* –û—à–∏–±–æ–∫ CRC */
 283          static u16          g_diag_addr_err = 0;    /* –û—à–∏–±–æ–∫ –∞–¥—Ä–µ—Å–∞ */
 284          
 285          /* ---------------------------------------------------------------
 286           * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
 287           * ------------------------------------------------------------- */
 288          
 289          static void init_system(void)
 290          {
 291   1          EA = 0;
 292   1      
 293   1          PAGESEL   = 0x01;
 294   1          D_PAGESEL = 0x02;
 295   1          MUX_SEL   = 0x60;
 296   1          RAMMODE   = 0x00;
 297   1          PORTDRV   = 0x01;
 298   1      
 299   1          IEN0 = 0x00;
 300   1          IEN1 = 0x00;
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 6   

 301   1          IEN2 = 0x00;
 302   1      
 303   1          /* Timer0: –¥–ª—è RTC (1ms) */
 304   1          TMOD = 0x11;
 305   1          TH0 = (u8)(T1MS >> 8);
 306   1          TL0 = (u8)(T1MS & 0xFF);
 307   1          ET0 = 1;
 308   1          TR0 = 1;
 309   1      
 310   1          /* Timer2: –¥–ª—è delay_ms */
 311   1          T2CON  = 0x70;
 312   1          TH2    = 0x00;
 313   1          TL2    = 0x00;
 314   1          TRL2H  = 0xBC;
 315   1          TRL2L  = 0xCD;
 316   1          IEN0  |= 0x20;
 317   1          TR2    = 1;
 318   1      
 319   1          EA = 1;
 320   1      }
 321          
 322          /* –§–ª–∞–≥ –∑–∞–Ω—è—Ç–æ—Å—Ç–∏ –ø–µ—Ä–µ–¥–∞—Ç—á–∏–∫–∞ UART5 */
 323          static bit g_uart5_busy = 0;
 324          
 325          /* –ù–∞—Å—Ç—Ä–æ–π–∫–∞ UART5 –¥–ª—è Modbus RTU (RS485 –Ω–∞ –ø–ª–∞—Ç–µ DWIN TC040C11) */
 326          static void uart5_init(u8 speed_idx, u8 proto)
 327          {
 328   1          (void)proto;  /* –í T5L –∞–ø–ø–∞—Ä–∞—Ç–Ω–æ —Ç–æ–ª—å–∫–æ 8N1 */
*** WARNING C275 IN LINE 328 OF main.c: expression with possibly no effect
 329   1      
 330   1          /* P0.0, P0.1, P0.4 –≤ push-pull */
 331   1          P0MDOUT |= 0x13;  /* 0x01 | 0x02 | 0x10 = P0.0, P0.1, P0.4 */
 332   1      
 333   1          /* –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å TX –Ω–∞ –ø–ª–∞—Ç–µ - –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å = 1 */
 334   1          TX2_SEL = 1;
 335   1          
 336   1          /* –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∏–Ω—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
 337   1          TR4_PIN = 0;
 338   1          
 339   1          /* RS-485: –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–µ–∂–∏–º –ø—Ä–∏—ë–º–∞ */
 340   1          RS485_DE = 0;
 341   1      
 342   1          SCON3T = 0x80;      /* TX enable, 8 bit */
 343   1          SCON3R = 0x80;      /* RX enable, 8 bit */
 344   1      
 345   1          /* Baud rate –∏–∑ —Ä–∞–±–æ—á–µ–≥–æ –∫–æ–¥–∞: 
 346   1             9600:   BODE3_DIV_H=0x0A, BODE3_DIV_L=0x80
 347   1             115200: BODE3_DIV_H=0x00, BODE3_DIV_L=0xE0 */
 348   1          switch (speed_idx)
 349   1          {
 350   2              case 1:  /* 2400 - –ø—Ä–∏–º–µ—Ä–Ω—ã–π —Ä–∞—Å—á—ë—Ç */
 351   2                  BODE3_DIV_H = 0x2A;
 352   2                  BODE3_DIV_L = 0x00;
 353   2                  break;
 354   2              case 2:  /* 4800 */
 355   2                  BODE3_DIV_H = 0x15;
 356   2                  BODE3_DIV_L = 0x00;
 357   2                  break;
 358   2              case 3:  /* 9600 - –∏–∑ —Ä–∞–±–æ—á–µ–≥–æ –∫–æ–¥–∞ */
 359   2                  BODE3_DIV_H = 0x0A;
 360   2                  BODE3_DIV_L = 0x80;
 361   2                  break;
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 7   

 362   2              case 4:  /* 19200 */
 363   2                  BODE3_DIV_H = 0x05;
 364   2                  BODE3_DIV_L = 0x40;
 365   2                  break;
 366   2              case 5:  /* 38400 */
 367   2                  BODE3_DIV_H = 0x02;
 368   2                  BODE3_DIV_L = 0xA0;
 369   2                  break;
 370   2              case 6:  /* 57600 */
 371   2                  BODE3_DIV_H = 0x01;
 372   2                  BODE3_DIV_L = 0xC0;
 373   2                  break;
 374   2              case 7:  /* 115200 - –∏–∑ —Ä–∞–±–æ—á–µ–≥–æ –∫–æ–¥–∞ */
 375   2              default:
 376   2                  BODE3_DIV_H = 0x00;
 377   2                  BODE3_DIV_L = 0xE0;
 378   2                  break;
 379   2          }
 380   1      
 381   1          /* –í–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è UART5: TX –∏ RX */
 382   1          ES3T = 1;
 383   1          ES3R = 1;
 384   1      
 385   1          EA = 1;
 386   1      }
 387          
 388          static void init_relays(void)
 389          {
 390   1          P1MDOUT |= (RELAY_VALVE_BIT | RELAY_LOW_BIT | RELAY_HIGH_BIT | RELAY_MID_BIT);
 391   1          RELAY_VALVE = 1;
 392   1          RELAY_LOW   = 0;
 393   1          RELAY_MID   = 0;
 394   1          RELAY_HIGH  = 0;
 395   1          g_valve_open = 1;
 396   1      }
 397          
 398          /* ---------------------------------------------------------------
 399           * –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ç–∞–π–º–µ—Ä–æ–≤
 400           * ------------------------------------------------------------- */
 401          
 402          void T0_ISR(void) interrupt 1
 403          {
 404   1          EA = 0;
 405   1          TH0 = (u8)(T1MS >> 8);
 406   1          TL0 = (u8)(T1MS & 0xFF);
 407   1      
 408   1          ++SysTick_RTC;
 409   1          if (SysTick_RTC >= 1000u)
 410   1          {
 411   2              SysTick_RTC = 0;
 412   2              g_rtc_1s_flag = 1;
 413   2          }
 414   1      
 415   1          /* –¢–∞–π–º–∞—É—Ç Modbus */
 416   1          if (g_mb_rx_timeout > 0)
 417   1          {
 418   2              --g_mb_rx_timeout;
 419   2              if (g_mb_rx_timeout == 0 && g_mb_rx_cnt > 0)
 420   2              {
 421   3                  g_mb_frame_ready = 1;
 422   3              }
 423   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 8   

 424   1      
 425   1          EA = 1;
 426   1      }
 427          
 428          void T2_ISR(void) interrupt 5
 429          {
 430   1          EA = 0;
 431   1          TF2 = 0;
 432   1          if (SysTick) --SysTick;
 433   1          EA = 1;
 434   1      }
 435          
 436          /* –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø—Ä–∏—ë–º–∞ UART5 */
 437          void UART5_RX_ISR(void) interrupt 13
 438          {
 439   1          u8 res;
 440   1          EA = 0;
 441   1      
 442   1          if (SCON3R & 0x01)
 443   1          {
 444   2              res = SBUF3_RX;
 445   2              SCON3R &= 0xFE;
 446   2      
 447   2              if (g_mb_rx_cnt < MODBUS_RX_BUF_SIZE)
 448   2              {
 449   3                  g_mb_rx_buf[g_mb_rx_cnt++] = res;
 450   3              }
 451   2              g_mb_rx_timeout = MODBUS_TIMEOUT_MS;
 452   2              g_mb_frame_ready = 0;
 453   2              
 454   2              /* –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: —Å—á–∏—Ç–∞–µ–º –ø—Ä–∏–Ω—è—Ç—ã–µ –±–∞–π—Ç—ã */
 455   2              g_diag_rx_total++;
 456   2          }
 457   1      
 458   1          EA = 1;
 459   1      }
 460          
 461          /* –ü—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–¥–∞—á–∏ UART5 */
 462          void UART5_TX_ISR(void) interrupt 12
 463          {
 464   1          SCON3T &= 0xFE;  /* –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ */
 465   1          g_uart5_busy = 0;
 466   1      }
 467          
 468          static void delay_ms(u16 n)
 469          {
 470   1          SysTick = n;
 471   1          while (SysTick) { }
 472   1      }
 473          
 474          /* ---------------------------------------------------------------
 475           * UART5 –æ—Ç–ø—Ä–∞–≤–∫–∞ (RS485 —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –Ω–∞ P0.1)
 476           * ------------------------------------------------------------- */
 477          
 478          static void uart5_send_byte(u8 dat)
 479          {
 480   1          while (g_uart5_busy) ;  /* –ñ–¥—ë–º –ø–æ–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏–π –±–∞–π—Ç –æ—Ç–ø—Ä–∞–≤–∏—Ç—Å—è */
 481   1          g_uart5_busy = 1;
 482   1          SBUF3_TX = dat;
 483   1      }
 484          
 485          static void uart5_send_buf(u8 *buf, u8 len)
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 9   

 486          {
 487   1          RS485_DE = 1;  /* –í–∫–ª—é—á–∞–µ–º –ø–µ—Ä–µ–¥–∞—Ç—á–∏–∫ RS485 */
 488   1      
 489   1          while (len--)
 490   1          {
 491   2              uart5_send_byte(*buf++);
 492   2          }
 493   1      
 494   1          while (g_uart5_busy) ;  /* –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –±–∞–π—Ç–∞ */
 495   1          RS485_DE = 0;  /* –í—ã–∫–ª—é—á–∞–µ–º –ø–µ—Ä–µ–¥–∞—Ç—á–∏–∫ RS485 */
 496   1      }
 497          
 498          /* ---------------------------------------------------------------
 499           * Modbus CRC16
 500           * ------------------------------------------------------------- */
 501          
 502          static u16 modbus_crc16(u8 *buf, u8 len)
 503          {
 504   1          u8 crc_hi = 0xFF;
 505   1          u8 crc_lo = 0xFF;
 506   1          u8 idx;
 507   1      
 508   1          while (len--)
 509   1          {
 510   2              idx = crc_hi ^ *buf++;
 511   2              crc_hi = crc_lo ^ CRC_HI[idx];
 512   2              crc_lo = CRC_LO[idx];
 513   2          }
 514   1      
 515   1          return ((u16)crc_hi << 8) | crc_lo;
 516   1      }
 517          
 518          /* ---------------------------------------------------------------
 519           * –î–æ—Å—Ç—É–ø –∫ VP DGUS
 520           * ------------------------------------------------------------- */
 521          
 522          static void read_dgus_vp(u16 addr, u8 *buf, u16 len)
 523          {
 524   1          u32 os_addr;
 525   1          u16 os_len;
 526   1          u8  offset;
 527   1      
 528   1          os_addr = (u32)addr / 2U;
 529   1          offset  = (u8)(addr & 0x01);
 530   1      
 531   1          ADR_H = (u8)((os_addr >> 16) & 0xFFU);
 532   1          ADR_M = (u8)((os_addr >> 8)  & 0xFFU);
 533   1          ADR_L = (u8)(os_addr & 0xFFU);
 534   1      
 535   1          ADR_INC = 1;
 536   1          RAMMODE = 0xAF;
 537   1      
 538   1          if (offset)
 539   1          {
 540   2              while (!APP_ACK) ;
 541   2              APP_EN = 1;
 542   2              while (APP_EN) ;
 543   2              *buf++ = DATA1;
 544   2              *buf++ = DATA0;
 545   2              --len;
 546   2          }
 547   1      
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 10  

 548   1          os_len = len / 2U;
 549   1          if (len & 0x01) ++os_len;
 550   1      
 551   1          while (os_len--)
 552   1          {
 553   2              if ((len & 0x01) && (os_len == 0))
 554   2              {
 555   3                  while (!APP_ACK) ;
 556   3                  APP_EN = 1;
 557   3                  while (APP_EN) ;
 558   3                  *buf++ = DATA3;
 559   3                  *buf++ = DATA2;
 560   3                  break;
 561   3              }
 562   2      
 563   2              while (!APP_ACK) ;
 564   2              APP_EN = 1;
 565   2              while (APP_EN) ;
 566   2              *buf++ = DATA3;
 567   2              *buf++ = DATA2;
 568   2              *buf++ = DATA1;
 569   2              *buf++ = DATA0;
 570   2          }
 571   1      
 572   1          RAMMODE = 0x00;
 573   1      }
 574          
 575          static void write_dgus_vp(u16 vp_addr, const u8 *buf, u16 len)
 576          {
 577   1          u32 os_addr;
 578   1          u16 os_len;
 579   1          u8  odd;
 580   1      
 581   1          EA = 0;
 582   1      
 583   1          os_addr = (u32)vp_addr / 2U;
 584   1          odd     = (u8)(vp_addr & 0x01);
 585   1      
 586   1          ADR_H = (u8)((os_addr >> 16) & 0xFFU);
 587   1          ADR_M = (u8)((os_addr >> 8)  & 0xFFU);
 588   1          ADR_L = (u8)(os_addr & 0xFFU);
 589   1      
 590   1          ADR_INC = 0x01;
 591   1          RAMMODE = 0x8F;
 592   1      
 593   1          if (odd)
 594   1          {
 595   2              ADR_INC = 0x00;
 596   2              RAMMODE = 0xAF;
 597   2              while (!APP_ACK) ;
 598   2              APP_EN = 1;
 599   2              while (APP_EN) ;
 600   2      
 601   2              ADR_INC = 0x01;
 602   2              RAMMODE = 0x8F;
 603   2              while (!APP_ACK) ;
 604   2              DATA1 = *buf++;
 605   2              DATA0 = *buf++;
 606   2              APP_EN = 1;
 607   2              while (APP_EN) ;
 608   2              --len;
 609   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 11  

 610   1      
 611   1          os_len = len / 2U;
 612   1          if (len & 0x01) ++os_len;
 613   1      
 614   1          while (os_len--)
 615   1          {
 616   2              if ((len & 0x01) && (os_len == 0))
 617   2              {
 618   3                  ADR_INC = 0x00;
 619   3                  RAMMODE = 0xAF;
 620   3                  while (!APP_ACK) ;
 621   3                  APP_EN = 1;
 622   3                  while (APP_EN) ;
 623   3      
 624   3                  ADR_INC = 0x01;
 625   3                  RAMMODE = 0x8F;
 626   3                  while (!APP_ACK) ;
 627   3                  DATA3 = *buf++;
 628   3                  DATA2 = *buf++;
 629   3                  APP_EN = 1;
 630   3                  while (APP_EN) ;
 631   3                  break;
 632   3              }
 633   2      
 634   2              while (!APP_ACK) ;
 635   2              DATA3 = *buf++;
 636   2              DATA2 = *buf++;
 637   2              DATA1 = *buf++;
 638   2              DATA0 = *buf++;
 639   2              APP_EN = 1;
 640   2              while (APP_EN) ;
 641   2          }
 642   1      
 643   1          RAMMODE = 0x00;
 644   1          EA = 1;
 645   1      }
 646          
 647          static void write_vp_u16(u16 vp_addr, u16 value)
 648          {
 649   1          u8 buf[2];
 650   1          buf[0] = (u8)(value >> 8);
 651   1          buf[1] = (u8)(value & 0xFF);
 652   1          write_dgus_vp(vp_addr, buf, 1);  /* len=1 —Å–ª–æ–≤–æ (2 –±–∞–π—Ç–∞) */
 653   1      }
 654          
 655          static u16 read_vp_u16(u16 vp_addr)
 656          {
 657   1          u8 buf[2];
 658   1          read_dgus_vp(vp_addr, buf, 1);
 659   1          return ((u16)buf[0] << 8) | buf[1];
 660   1      }
 661          
 662          /* ---------------------------------------------------------------
 663           * Modbus: —á—Ç–µ–Ω–∏–µ/–∑–∞–ø–∏—Å—å —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
 664           * ------------------------------------------------------------- */
 665          
 666          /* –ß—Ç–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è Modbus —Ä–µ–≥–∏—Å—Ç—Ä–∞ –ø–æ –∞–¥—Ä–µ—Å—É */
 667          static u16 modbus_read_reg(u16 addr)
 668          {
 669   1          /* –ì—Ä–∞—Ñ–∏–∫–∏ 1..4: –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è VP */
 670   1          if (addr >= 0x2020 && addr <= 0x2057)
 671   1          {
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 12  

 672   2              return read_vp_u16(addr);
 673   2          }
 674   1      
 675   1          switch (addr)
 676   1          {
 677   2              /* –î–∞—Ç–∞/–≤—Ä–µ–º—è (—Ç–æ–ª—å–∫–æ —á—Ç–µ–Ω–∏–µ) */
 678   2              case 0x2010: return 2000u + g_rtc.year;
 679   2              case 0x2011: return g_rtc.month;
 680   2              case 0x2012: return g_rtc.day;
 681   2              case 0x2013: return g_rtc.weekday;
 682   2              case 0x2014: return g_rtc.hour;
 683   2              case 0x2015: return g_rtc.min;
 684   2              case 0x2016: return g_rtc.sec;
 685   2      
 686   2              /* –û—Å–Ω–æ–≤–Ω—ã–µ —Ä–µ–≥–∏—Å—Ç—Ä—ã */
 687   2              case 0x2060: return g_onoff;
 688   2              case 0x2061: return g_speed;
 689   2              case 0x2062: return g_mode;
 690   2              case 0x2063: return g_t_real_10x;
 691   2              case 0x2064: return g_t_real_10x / 10u;
 692   2              case 0x2065: return g_t_set_10x;
 693   2              case 0x2066: return g_t_set_10x / 10u;
 694   2              case 0x2067: return g_graph_en;
 695   2      
 696   2              /* –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Modbus */
 697   2              case 0x2070: return g_mb_addr;
 698   2              case 0x2071: return g_mb_speed_idx;
 699   2              case 0x2072: return g_mb_proto;
 700   2      
 701   2              default:     return 0;
 702   2          }
 703   1      }
 704          
 705          /* –ó–∞–ø–∏—Å—å –∑–Ω–∞—á–µ–Ω–∏—è –≤ Modbus —Ä–µ–≥–∏—Å—Ç—Ä */
 706          static u8 modbus_write_reg(u16 addr, u16 value)
 707          {
 708   1          /* –ì—Ä–∞—Ñ–∏–∫–∏ 1..4: –ø–∏—à–µ–º –Ω–∞–ø—Ä—è–º—É—é –≤ VP, –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è —É–
             -∂–µ –ª–æ–≥–∏–∫–æ–π –≥—Ä–∞—Ñ–∏–∫–æ–≤ */
 709   1          if (addr >= 0x2020 && addr <= 0x2057)
 710   1          {
 711   2              write_vp_u16(addr, value);
 712   2              return 1;
 713   2          }
 714   1      
 715   1          switch (addr)
 716   1          {
 717   2              case 0x2060:  /* ON/OFF */
 718   2                  if (value == 1 || value == 2)
 719   2                  {
 720   3                      g_onoff = (u8)value;
 721   3                      write_vp_u16(VP_ONOFF, value);
 722   3                      return 1;
 723   3                  }
 724   2                  break;
 725   2      
 726   2              case 0x2061:  /* –°–∫–æ—Ä–æ—Å—Ç—å */
 727   2                  if (value >= 1 && value <= 4)
 728   2                  {
 729   3                      g_speed = (u8)value;
 730   3                      write_vp_u16(VP_SPEED, value);
 731   3                      return 1;
 732   3                  }
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 13  

 733   2                  break;
 734   2      
 735   2              case 0x2062:  /* –†–µ–∂–∏–º */
 736   2                  if (value == 1 || value == 2)
 737   2                  {
 738   3                      g_mode = (u8)value;
 739   3                      write_vp_u16(VP_MODE, value);
 740   3                      return 1;
 741   3                  }
 742   2                  break;
 743   2      
 744   2              case 0x2065:  /* –£—Å—Ç–∞–≤–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã (*10) */
 745   2                  if (value >= 160 && value <= 320)
 746   2                  {
 747   3                      g_t_set_10x = value;
 748   3                      write_vp_u16(VP_T_SET_10X, value);
 749   3                      write_vp_u16(VP_T_SET_INT, value / 10u);
 750   3                      return 1;
 751   3                  }
 752   2                  break;
 753   2      
 754   2              case 0x2067:  /* –ì—Ä–∞—Ñ–∏–∫–∏ –≤–∫–ª/–≤—ã–∫–ª */
 755   2                  if (value == 1 || value == 2)
 756   2                  {
 757   3                      g_graph_en = (u8)value;
 758   3                      write_vp_u16(VP_GRAPH_EN, value);
 759   3                      return 1;
 760   3                  }
 761   2                  break;
 762   2      
 763   2              case 0x2070:  /* –ê–¥—Ä–µ—Å Modbus */
 764   2                  if (value >= 1 && value <= 247)
 765   2                  {
 766   3                      g_mb_addr = (u8)value;
 767   3                      write_vp_u16(VP_MB_ADDR, value);
 768   3                      return 1;
 769   3                  }
 770   2                  break;
 771   2      
 772   2              case 0x2071:  /* –°–∫–æ—Ä–æ—Å—Ç—å Modbus */
 773   2                  if (value >= 1 && value <= 7)
 774   2                  {
 775   3                      g_mb_speed_idx = (u8)value;
 776   3                      write_vp_u16(VP_MB_SPEED, value);
 777   3                      uart5_init(g_mb_speed_idx, g_mb_proto);
 778   3                      return 1;
 779   3                  }
 780   2                  break;
 781   2      
 782   2              case 0x2072:  /* –ü—Ä–æ—Ç–æ–∫–æ–ª Modbus (—Ö—Ä–∞–Ω–∏–º, –Ω–æ —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –ø–æ–∫–∞ 8N1) */
 783   2                  if (value >= 1 && value <= 6)
 784   2                  {
 785   3                      g_mb_proto = (u8)value;
 786   3                      write_vp_u16(VP_MB_PROTO, value);
 787   3                      /* uart5_init(...) –æ—Å—Ç–∞–≤–ª—è–µ–º ‚Äî –≤–¥—Ä—É–≥ –ø–æ—Ç–æ–º —Ä–µ–∞–ª–∏–∑—É–µ—Ç–µ –ø–æ–
             -¥–¥–µ—Ä–∂–∫—É parity */
 788   3                      uart5_init(g_mb_speed_idx, g_mb_proto);
 789   3                      return 1;
 790   3                  }
 791   2                  break;
 792   2          }
 793   1      
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 14  

 794   1          return 0;
 795   1      }
 796          
 797          /* –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–ø—É—Å—Ç–∏–º–æ—Å—Ç–∏ –∞–¥—Ä–µ—Å–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞ */
 798          static u8 modbus_addr_valid(u16 addr)
 799          {
 800   1          if (addr >= 0x2010 && addr <= 0x2016) return 1;  /* –î–∞—Ç–∞/–≤—Ä–µ–º—è */
 801   1          if (addr >= 0x2020 && addr <= 0x2057) return 1;  /* –ì—Ä–∞—Ñ–∏–∫–∏ 1..4 */
 802   1          if (addr >= 0x2060 && addr <= 0x2067) return 1;  /* –û—Å–Ω–æ–≤–Ω—ã–µ —Ä–µ–≥–∏—Å—Ç—Ä—ã */
 803   1          if (addr >= 0x2070 && addr <= 0x2072) return 1;  /* –ù–∞—Å—Ç—Ä–æ–π–∫–∏ Modbus */
 804   1          return 0;
 805   1      }
 806          
 807          /* ---------------------------------------------------------------
 808           * –û–±—Ä–∞–±–æ—Ç–∫–∞ Modbus RTU —Ñ—Ä–µ–π–º–∞
 809           * ------------------------------------------------------------- */
 810          
 811          static void modbus_process_frame(void)
 812          {
 813   1          u8 addr, func;
 814   1          u16 reg_addr, reg_cnt, reg_val;
 815   1          u16 crc_recv, crc_calc;
 816   1          u8 i, tx_len;
 817   1      
 818   1          /* –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: –∑–∞–ø–∏—Å—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–Ω—è—Ç—ã—Ö –±–∞–π—Ç */
 819   1          write_vp_u16(VP_DIAG_RX_CNT, g_diag_rx_total);
 820   1      
 821   1          if (g_mb_rx_cnt < 4) goto cleanup;
 822   1      
 823   1          /* –ü—Ä–æ–≤–µ—Ä–∫–∞ CRC (–ø–æ—Ä—è–¥–æ–∫: buf[len-2]=CRC_HI, buf[len-1]=CRC_LO) */
 824   1          crc_calc = modbus_crc16(g_mb_rx_buf, g_mb_rx_cnt - 2);
 825   1          crc_recv = ((u16)g_mb_rx_buf[g_mb_rx_cnt - 2] << 8) | g_mb_rx_buf[g_mb_rx_cnt - 1];
 826   1      
 827   1          if (crc_calc != crc_recv)
 828   1          {
 829   2              g_diag_crc_err++;
 830   2              write_vp_u16(VP_DIAG_CRC_ERR, g_diag_crc_err);
 831   2              goto cleanup;
 832   2          }
 833   1      
 834   1          addr = g_mb_rx_buf[0];
 835   1          func = g_mb_rx_buf[1];
 836   1      
 837   1          /* –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥—Ä–µ—Å–∞ */
 838   1          if (addr != g_mb_addr && addr != 0)
 839   1          {
 840   2              g_diag_addr_err++;
 841   2              write_vp_u16(VP_DIAG_ADDR_ERR, g_diag_addr_err);
 842   2              goto cleanup;
 843   2          }
 844   1          
 845   1          /* –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞: —É—Å–ø–µ—à–Ω—ã–π –∫–∞–¥—Ä */
 846   1          g_diag_frame_ok++;
 847   1          write_vp_u16(VP_DIAG_FRAME_OK, g_diag_frame_ok);
 848   1      
 849   1          /* –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ—É–Ω–∫—Ü–∏–π */
 850   1          switch (func)
 851   1          {
 852   2              case MB_FUNC_READ_REGS:  /* 0x03: Read Holding Registers */
 853   2                  if (g_mb_rx_cnt < 8) goto cleanup;
 854   2      
 855   2                  reg_addr = ((u16)g_mb_rx_buf[2] << 8) | g_mb_rx_buf[3];
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 15  

 856   2                  reg_cnt  = ((u16)g_mb_rx_buf[4] << 8) | g_mb_rx_buf[5];
 857   2      
 858   2                  if (reg_cnt == 0 || reg_cnt > 125) goto send_error_value;
 859   2      
 860   2                  /* –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥—Ä–µ—Å–æ–≤ */
 861   2                  for (i = 0; i < reg_cnt; ++i)
 862   2                  {
 863   3                      if (!modbus_addr_valid(reg_addr + i)) goto send_error_addr;
 864   3                  }
 865   2      
 866   2                  /* –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç */
 867   2                  g_mb_tx_buf[0] = addr;
 868   2                  g_mb_tx_buf[1] = func;
 869   2                  g_mb_tx_buf[2] = (u8)(reg_cnt * 2);
 870   2                  tx_len = 3;
 871   2      
 872   2                  for (i = 0; i < reg_cnt; ++i)
 873   2                  {
 874   3                      reg_val = modbus_read_reg(reg_addr + i);
 875   3                      g_mb_tx_buf[tx_len++] = (u8)(reg_val >> 8);
 876   3                      g_mb_tx_buf[tx_len++] = (u8)(reg_val & 0xFF);
 877   3                  }
 878   2      
 879   2                  /* CRC (–ø–æ—Ä—è–¥–æ–∫: CRC_HI –ø–µ—Ä–≤—ã–º, CRC_LO –≤—Ç–æ—Ä—ã–º) */
 880   2                  crc_calc = modbus_crc16(g_mb_tx_buf, tx_len);
 881   2                  g_mb_tx_buf[tx_len++] = (u8)(crc_calc >> 8);
 882   2                  g_mb_tx_buf[tx_len++] = (u8)(crc_calc & 0xFF);
 883   2      
 884   2                  if (addr != 0) uart5_send_buf(g_mb_tx_buf, tx_len);
 885   2                  break;
 886   2      
 887   2              case MB_FUNC_WRITE_REG:  /* 0x06: Write Single Register */
 888   2                  if (g_mb_rx_cnt < 8) goto cleanup;
 889   2      
 890   2                  reg_addr = ((u16)g_mb_rx_buf[2] << 8) | g_mb_rx_buf[3];
 891   2                  reg_val  = ((u16)g_mb_rx_buf[4] << 8) | g_mb_rx_buf[5];
 892   2      
 893   2                  if (!modbus_addr_valid(reg_addr)) goto send_error_addr;
 894   2      
 895   2                  if (!modbus_write_reg(reg_addr, reg_val)) goto send_error_value;
 896   2      
 897   2                  /* –û—Ç–≤–µ—Ç = —ç—Ö–æ –∑–∞–ø—Ä–æ—Å–∞ */
 898   2                  if (addr != 0)
 899   2                  {
 900   3                      uart5_send_buf(g_mb_rx_buf, g_mb_rx_cnt);
 901   3                  }
 902   2                  break;
 903   2      
 904   2              case MB_FUNC_WRITE_REGS:  /* 0x10: Write Multiple Registers */
 905   2                  if (g_mb_rx_cnt < 9) goto cleanup;
 906   2      
 907   2                  reg_addr = ((u16)g_mb_rx_buf[2] << 8) | g_mb_rx_buf[3];
 908   2                  reg_cnt  = ((u16)g_mb_rx_buf[4] << 8) | g_mb_rx_buf[5];
 909   2      
 910   2                  if (reg_cnt == 0 || reg_cnt > 123) goto send_error_value;
 911   2                  if (g_mb_rx_cnt < (9 + reg_cnt * 2)) goto cleanup;
 912   2      
 913   2                  /* –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∑–∞–ø–∏—Å—å */
 914   2                  for (i = 0; i < reg_cnt; ++i)
 915   2                  {
 916   3                      if (!modbus_addr_valid(reg_addr + i)) goto send_error_addr;
 917   3                  }
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 16  

 918   2      
 919   2                  for (i = 0; i < reg_cnt; ++i)
 920   2                  {
 921   3                      reg_val = ((u16)g_mb_rx_buf[7 + i * 2] << 8) | g_mb_rx_buf[8 + i * 2];
 922   3                      modbus_write_reg(reg_addr + i, reg_val);
 923   3                  }
 924   2      
 925   2                  /* –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç */
 926   2                  g_mb_tx_buf[0] = addr;
 927   2                  g_mb_tx_buf[1] = func;
 928   2                  g_mb_tx_buf[2] = g_mb_rx_buf[2];
 929   2                  g_mb_tx_buf[3] = g_mb_rx_buf[3];
 930   2                  g_mb_tx_buf[4] = g_mb_rx_buf[4];
 931   2                  g_mb_tx_buf[5] = g_mb_rx_buf[5];
 932   2      
 933   2                  crc_calc = modbus_crc16(g_mb_tx_buf, 6);
 934   2                  g_mb_tx_buf[6] = (u8)(crc_calc >> 8);
 935   2                  g_mb_tx_buf[7] = (u8)(crc_calc & 0xFF);
 936   2      
 937   2                  if (addr != 0) uart5_send_buf(g_mb_tx_buf, 8);
 938   2                  break;
 939   2      
 940   2              default:
 941   2                  goto send_error_func;
 942   2          }
 943   1      
 944   1          goto cleanup;
 945   1      
 946   1      send_error_func:
 947   1          g_mb_tx_buf[0] = addr;
 948   1          g_mb_tx_buf[1] = func | 0x80;
 949   1          g_mb_tx_buf[2] = MB_ERR_ILLEGAL_FUNC;
 950   1          crc_calc = modbus_crc16(g_mb_tx_buf, 3);
 951   1          g_mb_tx_buf[3] = (u8)(crc_calc >> 8);
 952   1          g_mb_tx_buf[4] = (u8)(crc_calc & 0xFF);
 953   1          if (addr != 0) uart5_send_buf(g_mb_tx_buf, 5);
 954   1          goto cleanup;
 955   1      
 956   1      send_error_addr:
 957   1          g_mb_tx_buf[0] = addr;
 958   1          g_mb_tx_buf[1] = func | 0x80;
 959   1          g_mb_tx_buf[2] = MB_ERR_ILLEGAL_ADDR;
 960   1          crc_calc = modbus_crc16(g_mb_tx_buf, 3);
 961   1          g_mb_tx_buf[3] = (u8)(crc_calc >> 8);
 962   1          g_mb_tx_buf[4] = (u8)(crc_calc & 0xFF);
 963   1          if (addr != 0) uart5_send_buf(g_mb_tx_buf, 5);
 964   1          goto cleanup;
 965   1      
 966   1      send_error_value:
 967   1          g_mb_tx_buf[0] = addr;
 968   1          g_mb_tx_buf[1] = func | 0x80;
 969   1          g_mb_tx_buf[2] = MB_ERR_ILLEGAL_VALUE;
 970   1          crc_calc = modbus_crc16(g_mb_tx_buf, 3);
 971   1          g_mb_tx_buf[3] = (u8)(crc_calc >> 8);
 972   1          g_mb_tx_buf[4] = (u8)(crc_calc & 0xFF);
 973   1          if (addr != 0) uart5_send_buf(g_mb_tx_buf, 5);
 974   1      
 975   1      cleanup:
 976   1          g_mb_rx_cnt = 0;
 977   1          g_mb_frame_ready = 0;
 978   1      }
 979          
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 17  

 980          /* ---------------------------------------------------------------
 981           * –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–ª–µ
 982           * ------------------------------------------------------------- */
 983          
 984          static void relays_speeds_off(void)
 985          {
 986   1          RELAY_LOW  = 0;
 987   1          RELAY_MID  = 0;
 988   1          RELAY_HIGH = 0;
 989   1      }
 990          
 991          static void set_valve(bit open)
 992          {
 993   1          RELAY_VALVE = open ? 1 : 0;
 994   1          g_valve_open = open;
 995   1      }
 996          
 997          static void set_speed_relays(u8 speed)
 998          {
 999   1          relays_speeds_off();
1000   1          switch (speed)
1001   1          {
1002   2              case 1: RELAY_LOW = 1;  break;
1003   2              case 2: RELAY_MID = 1;  break;
1004   2              case 3: RELAY_HIGH = 1; break;
1005   2          }
1006   1      }
1007          
1008          static void apply_off_state(void)
1009          {
1010   1          relays_speeds_off();
1011   1          set_valve(1);
1012   1      }
1013          
1014          /* ---------------------------------------------------------------
1015           * RTC
1016           * ------------------------------------------------------------- */
1017          
1018          static bit is_leap_year(u16 year)
1019          {
1020   1          if ((year % 400u) == 0u) return 1;
1021   1          if ((year % 100u) == 0u) return 0;
1022   1          if ((year % 4u) == 0u) return 1;
1023   1          return 0;
1024   1      }
1025          
1026          static u8 calc_weekday(u8 year, u8 month, u8 day)
1027          {
1028   1          /* –§–æ—Ä–º—É–ª–∞ –¢–æ–º–æ—Ö–∏–∫–æ –°–∞–∫–∞–º–æ—Ç–æ - –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º */
1029   1          static const u8 code t[] = {0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4};
1030   1          u16 y = (u16)year + 2000u;
1031   1          u8 m = month;
1032   1          u8 d = day;
1033   1          u16 result;
1034   1          
1035   1          if (m < 3) y--;
1036   1          
1037   1          result = (y + y/4u - y/100u + y/400u + t[m - 1u] + d) % 7u;
1038   1          
1039   1          /* –†–µ–∑—É–ª—å—Ç–∞—Ç: 0=–í—Å, 1=–ü–Ω, 2=–í—Ç, 3=–°—Ä, 4=–ß—Ç, 5=–ü—Ç, 6=–°–±
1040   1           * –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤: 1=–ü–Ω, 2=–í—Ç, 3=–°—Ä, 4=–ß—Ç, 5=–ü—Ç, 6=–°–±, 7=–í—Å */
1041   1          if (result == 0) return 7u;  /* –í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ */
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 18  

1042   1          return (u8)result;
1043   1      }
1044          
1045          static void rtc_tick_1s(void)
1046          {
1047   1          u8 dim;
1048   1      
1049   1          g_rtc.sec++;
1050   1          if (g_rtc.sec >= 60)
1051   1          {
1052   2              g_rtc.sec = 0;
1053   2              g_rtc.min++;
1054   2              if (g_rtc.min >= 60)
1055   2              {
1056   3                  g_rtc.min = 0;
1057   3                  g_rtc.hour++;
1058   3                  if (g_rtc.hour >= 24)
1059   3                  {
1060   4                      g_rtc.hour = 0;
1061   4                      g_rtc.day++;
1062   4      
1063   4                      dim = mon_table[g_rtc.month - 1];
1064   4                      if ((g_rtc.month == 2) && is_leap_year((u16)g_rtc.year + 2000u))
1065   4                          dim = 29;
1066   4      
1067   4                      if (g_rtc.day > dim)
1068   4                      {
1069   5                          g_rtc.day = 1;
1070   5                          g_rtc.month++;
1071   5                          if (g_rtc.month > 12)
1072   5                          {
1073   6                              g_rtc.month = 1;
1074   6                              g_rtc.year++;
1075   6                          }
1076   5                      }
1077   4      
1078   4                      g_rtc.weekday = calc_weekday(g_rtc.year, g_rtc.month, g_rtc.day);
1079   4                  }
1080   3              }
1081   2          }
1082   1      }
1083          
1084          static void rtc_read_from_dgus(void)
1085          {
1086   1          u16 vp_year, vp_month, vp_day, vp_hour, vp_min, vp_sec;
1087   1          u8 year_ok = 0, month_ok = 0, day_ok = 0;
1088   1          
1089   1          /* –ß–∏—Ç–∞–µ–º –∏–∑ VP —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ UI (0x2010-0x2016) */
1090   1          vp_year  = read_vp_u16(VP_YEAR);
1091   1          vp_month = read_vp_u16(VP_MONTH);
1092   1          vp_day   = read_vp_u16(VP_DAY);
1093   1          vp_hour  = read_vp_u16(VP_HOUR);
1094   1          vp_min   = read_vp_u16(VP_MIN);
1095   1          vp_sec   = read_vp_u16(VP_SEC);
1096   1          
1097   1          /* –ì–æ–¥: 2000-2100 */
1098   1          if (vp_year >= 2000 && vp_year <= 2100)
1099   1          {
1100   2              g_rtc.year = (u8)(vp_year - 2000);
1101   2              year_ok = 1;
1102   2          }
1103   1          
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 19  

1104   1          /* –ú–µ—Å—è—Ü: 101-112 (—Ñ–æ—Ä–º–∞—Ç +100) –∏–ª–∏ 1-12 (–ø—Ä—è–º–æ–π) */
1105   1          if (vp_month >= 101 && vp_month <= 112)
1106   1          {
1107   2              g_rtc.month = (u8)(vp_month - 100);
1108   2              month_ok = 1;
1109   2          }
1110   1          else if (vp_month >= 1 && vp_month <= 12)
1111   1          {
1112   2              g_rtc.month = (u8)vp_month;
1113   2              month_ok = 1;
1114   2          }
1115   1          
1116   1          /* –î–µ–Ω—å: 101-131 (—Ñ–æ—Ä–º–∞—Ç +100) –∏–ª–∏ 1-31 (–ø—Ä—è–º–æ–π) */
1117   1          if (vp_day >= 101 && vp_day <= 131)
1118   1          {
1119   2              g_rtc.day = (u8)(vp_day - 100);
1120   2              day_ok = 1;
1121   2          }
1122   1          else if (vp_day >= 1 && vp_day <= 31)
1123   1          {
1124   2              g_rtc.day = (u8)vp_day;
1125   2              day_ok = 1;
1126   2          }
1127   1          
1128   1          /* –ß–∞—Å: 100-123 (—Ñ–æ—Ä–º–∞—Ç +100) –∏–ª–∏ 0-23 (–ø—Ä—è–º–æ–π) */
1129   1          if (vp_hour >= 100 && vp_hour <= 123)
1130   1              g_rtc.hour = (u8)(vp_hour - 100);
1131   1          else if (vp_hour <= 23)
1132   1              g_rtc.hour = (u8)vp_hour;
1133   1          
1134   1          /* –ú–∏–Ω—É—Ç—ã: 100-159 (—Ñ–æ—Ä–º–∞—Ç +100) –∏–ª–∏ 0-59 (–ø—Ä—è–º–æ–π) */
1135   1          if (vp_min >= 100 && vp_min <= 159)
1136   1              g_rtc.min = (u8)(vp_min - 100);
1137   1          else if (vp_min <= 59)
1138   1              g_rtc.min = (u8)vp_min;
1139   1          
1140   1          /* –°–µ–∫—É–Ω–¥—ã: 100-159 (—Ñ–æ—Ä–º–∞—Ç +100) –∏–ª–∏ 0-59 (–ø—Ä—è–º–æ–π) */
1141   1          if (vp_sec >= 100 && vp_sec <= 159)
1142   1              g_rtc.sec = (u8)(vp_sec - 100);
1143   1          else if (vp_sec <= 59)
1144   1              g_rtc.sec = (u8)vp_sec;
1145   1      
1146   1          g_rtc.weekday = calc_weekday(g_rtc.year, g_rtc.month, g_rtc.day);
1147   1      }
1148          
1149          static void rtc_publish_to_vp(void)
1150          {
1151   1          u8 day_val   = (g_rtc.day   >= 1 && g_rtc.day   <= 31) ? g_rtc.day   : 1;
1152   1          u8 month_val = (g_rtc.month >= 1 && g_rtc.month <= 12) ? g_rtc.month : 1;
1153   1      
1154   1          write_vp_u16(VP_YEAR,    2000u + g_rtc.year);
1155   1          write_vp_u16(VP_MONTH,   100u + month_val);   /* min 101, max 112 */
1156   1          write_vp_u16(VP_DAY,     100u + day_val);     /* min 101, max 131 */
1157   1          write_vp_u16(VP_WEEKDAY, g_rtc.weekday);
1158   1          write_vp_u16(VP_HOUR,    100u + g_rtc.hour);
1159   1          write_vp_u16(VP_MIN,     100u + g_rtc.min);
1160   1          write_vp_u16(VP_SEC,     100u + g_rtc.sec);
1161   1      }
1162          
1163          /* ---------------------------------------------------------------
1164           * –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞
1165           * ------------------------------------------------------------- */
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 20  

1166          
1167          
1168          /* –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã */
1169          static u16 adc_val[8] = {0};
1170          static u16 adc_value[8] = {0};
1171          static u16 R1_value = 0;
1172          static u16 R2_value = 0;
1173          static u16 R1_Temperature = 0;
1174          static u16 R2_Temperature = 0;
1175          static u16 Temperature_Real = 0;
1176          static u16 Temperatrue_Real_Old = 0;
1177          static u16 AD_Count = 0;
1178          static u16 Temp_Pre = 10;           /* –®–∞–≥ –≤ –¥–µ—Å—è—Ç—ã—Ö –≥—Ä–∞–¥—É—Å–∞: 5=0.5¬∞C, 10=1¬∞C */
1179          static s16 Temp_Coef[3] = {0, 0, 0}; /* K1, K2, C - –±—É–¥—É—Ç –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ VP –∏–ª–∏ —É—Å—Ç–∞–
             -Ω–æ–≤–ª–µ–Ω—ã –¥–µ—Ñ–æ–ª—Ç–æ–º */
1180          
1181          /* –°–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ */
1182          #define TEMP_FILTER_SIZE 16  /* –£–≤–µ–ª–∏—á–µ–Ω–æ –¥–ª—è –ª—É—á—à–µ–π —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ */
1183          static u16 temp_filter_buf[TEMP_FILTER_SIZE];
1184          static u8 temp_filter_idx = 0;
1185          static bit temp_filter_init = 0;  /* –§–ª–∞–≥ –ø–µ—Ä–≤–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ */
1186          
1187          /* –ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞–ª–∏–±—Ä–æ–≤–æ—á–Ω—ã—Ö –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã */
1188          static void init_temperature_calibration(void)
1189          {
1190   1          u16 prec;
1191   1      
1192   1          /* –¢–æ—á–Ω–æ—Å—Ç—å: 0 ‚Üí 0.5¬∞C (Temp_Pre=5), 1 ‚Üí 1.0¬∞C (Temp_Pre=10) */
1193   1          prec = read_vp_u16(VP_T_PRECISION);
1194   1          if (prec == 0)
1195   1          {
1196   2              Temp_Pre = 5;
1197   2          }
1198   1          else if (prec == 1)
1199   1          {
1200   2              Temp_Pre = 10;
1201   2          }
1202   1          else
1203   1          {
1204   2              Temp_Pre = 10;
1205   2              write_vp_u16(VP_T_PRECISION, 1);
1206   2          }
1207   1      
1208   1          /* –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã: —á–∏—Ç–∞–µ–º –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º */
1209   1          read_dgus_vp(VP_T_COEF, (u8 *)Temp_Coef, 3);
1210   1          
1211   1          /* –ü—Ä–æ–≤–µ—Ä–∫–∞: K1 –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å > 0, K1 –¥–æ–ª–∂–µ–Ω —Ä–∞–≤–Ω—è—Ç—å—Å—è K2 + 10 */
1212   1          if ((Temp_Coef[0] <= 0) || (Temp_Coef[1] < 0) || (Temp_Coef[0] != Temp_Coef[1] + 10))
1213   1          {
1214   2              /* –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –≤–∞—à–µ–≥–æ —Ç–µ—Ä–º–æ—Å
             -—Ç–∞—Ç–∞
1215   2               * 
1216   2               * –ö–ê–õ–ò–ë–†–û–í–ö–ê: –ï—Å–ª–∏ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–µ–≤–µ—Ä–Ω–æ, –∏–∑
             -–º–µ–Ω–∏—Ç–µ Temp_Coef[2]:
1217   2               * - –ï—Å–ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –í–´–®–ï —Ä–µ–∞–ª—å–Ω–æ–π: —É–º–µ–Ω—å—à–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ 
             -(—Å–¥–µ–ª–∞–π—Ç–µ –±–æ–ª–µ–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
1218   2               * - –ï—Å–ª–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –ù–ò–ñ–ï —Ä–µ–∞–ª—å–Ω–æ–π: —É–≤–µ–ª–∏—á—å—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ 
             -(—Å–¥–µ–ª–∞–π—Ç–µ –º–µ–Ω–µ–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
1219   2               * 
1220   2               * –§–æ—Ä–º—É–ª–∞: –∫–∞–∂–¥—ã–µ 10 –µ–¥–∏–Ω–∏—Ü Temp_Coef[2] = 1¬∞C
1221   2               * –ü—Ä–∏–º–µ—Ä: –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç 26.6¬∞C –≤–º–µ—Å—Ç–æ 22¬∞C ‚Üí —Ä–∞–∑–Ω–∏—Ü–∞ +4.6¬∞C
1222   2               *         –Ω—É–∂–Ω–æ —É–º–µ–Ω—å—à–∏—Ç—å –Ω–∞ 46 –µ–¥–∏–Ω–∏—Ü (4.6 * 10 = 46)
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 21  

1223   2               */
1224   2              Temp_Coef[0] = 10;
1225   2              Temp_Coef[1] = 0;
1226   2              Temp_Coef[2] = -1800;  /* –ë–∞–∑–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–π—Ç–µ –ø–æ—Å–ª–µ –
             -ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–∑–º–µ—Ä–µ–Ω–∏–π */
1227   2              
1228   2              /* –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¥–µ—Ñ–æ–ª—Ç –≤ VP –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è */
1229   2              write_dgus_vp(VP_T_COEF, (u8 *)Temp_Coef, 3);
1230   2          }
1231   1      }
1232          
1233          /* –ß—Ç–µ–Ω–∏–µ ADC –∑–Ω–∞—á–µ–Ω–∏–π (—Ç–æ—á–Ω–æ –∫–∞–∫ –≤ tttt) */
1234          static void Get_ADC_Value(void)
1235          {
1236   1          static u16 temp[8] = {0};
1237   1          read_dgus_vp(OS_AD_VALUE, (u8 *)temp, 8);
1238   1          adc_val[0] += temp[0];
1239   1          adc_val[6] += temp[6];
1240   1          adc_val[7] += temp[7];
1241   1      }
1242          
1243          /* –†–∞—Å—á—ë—Ç —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è NTC (—Ç–æ—á–Ω–æ –∫–∞–∫ –≤ tttt) */
1244          static void Get_R_Value(u16 n)
1245          {
1246   1          float R1_temp = 0.0f, R2_temp = 0.0f;
1247   1          
1248   1          adc_value[0] = adc_val[0] / n;
1249   1          adc_value[6] = adc_val[6] / n;
1250   1          adc_value[7] = adc_val[7] / n;
1251   1          
1252   1          R1_temp = adc_value[7] * 1.0f / (adc_value[6] - adc_value[7]);
1253   1          R2_temp = adc_value[0] * 1.0f / (adc_value[6] - adc_value[0]);
1254   1          
1255   1          R1_value = (u16)(R1_temp * 10000);
1256   1          R2_value = (u16)(R2_temp * 10000);
1257   1      }
1258          
1259          /* –ü–æ–∏—Å–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ NTC (—Ç–æ—á–Ω–æ –∫–∞–∫ –≤ tttt) */
1260          static u8 FindTab(const u16 *pTab, u8 Tablong, u16 dat)
1261          {
1262   1          u8 st = 0, ed = 0, m = 0;
1263   1          u8 i = 0;
1264   1          
1265   1          ed = NTC_TABLE_SIZE - 1;
1266   1          
1267   1          if (dat >= pTab[st])
1268   1              return st;
1269   1          else if (dat <= pTab[ed])
1270   1              return ed;
1271   1          
1272   1          while (st < ed)
1273   1          {
1274   2              m = (st + ed) / 2;
1275   2              if (dat == pTab[m])
1276   2                  break;
1277   2              if ((dat < pTab[m]) && (dat > pTab[m + 1]))
1278   2                  break;
1279   2              if (dat > pTab[m])
1280   2                  ed = m;
1281   2              else
1282   2                  st = m;
1283   2              if (i++ > Tablong)
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 22  

1284   2                  break;
1285   2          }
1286   1          
1287   1          if (st > ed)
1288   1              return 0;
1289   1          return m;
1290   1      }
1291          
1292          /* –°–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã */
1293          static u16 apply_temp_filter(u16 new_val)
1294          {
1295   1          u8 j;
1296   1          u32 sum = 0;
1297   1          
1298   1          /* –ü—Ä–∏ –ø–µ—Ä–≤–æ–º –≤—ã–∑–æ–≤–µ –∑–∞–ø–æ–ª–Ω—è–µ–º –≤–µ—Å—å –±—É—Ñ–µ—Ä –Ω–∞—á–∞–ª—å–Ω—ã–º –∑–Ω–∞—á
             -–µ–Ω–∏–µ–º */
1299   1          if (!temp_filter_init)
1300   1          {
1301   2              for (j = 0; j < TEMP_FILTER_SIZE; j++)
1302   2                  temp_filter_buf[j] = new_val;
1303   2              temp_filter_init = 1;
1304   2              temp_filter_idx = 0;
1305   2              return new_val;
1306   2          }
1307   1          
1308   1          /* –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä */
1309   1          temp_filter_buf[temp_filter_idx] = new_val;
1310   1          temp_filter_idx = (temp_filter_idx + 1) % TEMP_FILTER_SIZE;
1311   1          
1312   1          /* –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω–µ–µ –ø–æ –≤—Å–µ–º—É –±—É—Ñ–µ—Ä—É */
1313   1          for (j = 0; j < TEMP_FILTER_SIZE; j++)
1314   1              sum += temp_filter_buf[j];
1315   1          
1316   1          return (u16)(sum / TEMP_FILTER_SIZE);
1317   1      }
1318          
1319          /* –†–∞—Å—á—ë—Ç —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã - –ú–ò–ù–ò–ú–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø */
1320          static void Get_Temperature(u16 tim, u16 n)
1321          {
1322   1          static u16 i = 0;
1323   1          u8 idx1;
1324   1          u16 delta1;
1325   1          s16 adc_diff;
1326   1          float temp1 = 0;
1327   1          
1328   1          if (AD_Count > tim)
1329   1          {
1330   2              Get_ADC_Value();
1331   2              i++;
1332   2              if (i >= n)
1333   2              {
1334   3                  Get_R_Value(n);
1335   3                  
1336   3                  /* –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ ADC —Å –∑–∞–ø–∞—Å–æ–º */
1337   3                  adc_diff = (s16)adc_value[6] - (s16)adc_value[7];
1338   3                  if (adc_diff <= 10)  /* –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ä–∞–∑–Ω–∏—Ü–∞ 10 */
1339   3                  {
1340   4                      /* ADC –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º, –Ω–æ –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á—ë—
             -Ç—á–∏–∫ */
1341   4                      adc_val[0] = adc_val[6] = adc_val[7] = 0;
1342   4                      i = 0;
1343   4                      AD_Count = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 23  

1344   4                      return;
1345   4                  }
1346   3      
1347   3                  /* –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –ü–ï–†–í–´–ô –¥–∞—Ç—á–∏–∫ (ADC7) */
1348   3                  idx1 = FindTab(NTC1_TABLE, NTC_TABLE_SIZE, R1_value);
1349   3      
1350   3                  if (idx1 >= (NTC_TABLE_SIZE - 1u)) idx1 = NTC_TABLE_SIZE - 2u;
1351   3      
1352   3                  delta1 = NTC1_TABLE[idx1] - NTC1_TABLE[idx1 + 1u];
1353   3                  if (delta1 == 0u) delta1 = 1;  /* –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ 0 */
1354   3                  
1355   3                  temp1 = (NTC1_TABLE[idx1] - R1_value) * 1.0f / delta1;
1356   3                  R1_Temperature = (u16)idx1 * 10u + (u16)(temp1 * 10.0f);
1357   3                  
1358   3                  /* –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞: —Å–º–µ—â–µ–Ω–∏–µ -7¬∞C (70 –¥–µ—Å—è—Ç—ã—Ö) */
1359   3                  #define TEMP_OFFSET 70
1360   3                  
1361   3                  if (R1_Temperature > TEMP_OFFSET)
1362   3                      Temperature_Real = R1_Temperature - TEMP_OFFSET;
1363   3               
1364   3                  Temperatrue_Real_Old = Temperature_Real;
1365   3                  
1366   3                  g_t_real_10x = Temperature_Real;
1367   3                  write_vp_u16(VP_T_REAL_10X, g_t_real_10x);
1368   3                  write_vp_u16(VP_T_REAL_INT, g_t_real_10x / 10u);
1369   3                  
1370   3                  /* –°–±—Ä–æ—Å */
1371   3                  adc_val[0] = 0;
1372   3                  adc_val[6] = 0;
1373   3                  adc_val[7] = 0;
1374   3                  i = 0;
1375   3              }
1376   2              AD_Count = 0;
1377   2          }
1378   1      }
1379          
1380          /* –û–±—ë—Ä—Ç–∫–∞ –¥–ª—è –≤—ã–∑–æ–≤–∞ –∏–∑ main */
1381          static void update_temperature(void)
1382          {
1383   1          AD_Count++;
1384   1          /* tim=40 (@5 ms —Ü–∏–∫–ª–∞) * 10 –≤—ã–±–æ—Ä–æ–∫ ‚âà 2 s –Ω–∞ –æ–¥–Ω–æ –∏–∑–º–µ—Ä–µ–Ω–∏–µ */
1385   1          Get_Temperature(40, 10);
1386   1      }
1387          
1388          /* ---------------------------------------------------------------
1389           * –ß—Ç–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∏–∑ VP
1390           * ------------------------------------------------------------- */
1391          
1392          static void read_control_params_from_vp(void)
1393          {
1394   1          u16 tmp;
1395   1      
1396   1          tmp = read_vp_u16(VP_ONOFF);
1397   1          if (tmp == 1u || tmp == 2u)
1398   1              g_onoff = (u8)tmp;
1399   1      
1400   1          tmp = read_vp_u16(VP_SPEED);
1401   1          if (tmp >= 1u && tmp <= 4u)
1402   1              g_speed = (u8)tmp;
1403   1      
1404   1          tmp = read_vp_u16(VP_MODE);
1405   1          if (tmp == 1u || tmp == 2u)
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 24  

1406   1              g_mode = (u8)tmp;
1407   1      
1408   1          /* –£—Å—Ç–∞–≤–∫–∞ –º–æ–∂–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –∫–∞–∫ *10 (0x2065), —Ç–∞–∫ –∏ —Ç–æ–ª—å–∫–æ —Ü–µ–ª–∞—è
             - —á–∞—Å—Ç—å (0x2066) */
1409   1          tmp = read_vp_u16(VP_T_SET_10X);
1410   1          if (tmp >= 160u && tmp <= 320u)          /* 16.0...32.0 */
1411   1          {
1412   2              g_t_set_10x = tmp;
1413   2          }
1414   1          else
1415   1          {
1416   2              /* –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å –∏–∑ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ä–µ–≥–∏—Å—Ç—Ä–∞ */
1417   2              tmp = read_vp_u16(VP_T_SET_INT);
1418   2              if (tmp >= 16u && tmp <= 32u)
1419   2              {
1420   3                  g_t_set_10x = tmp * 10u;
1421   3                  /* –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –æ–±–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞ –≤ DGUS */
1422   3                  write_vp_u16(VP_T_SET_10X, g_t_set_10x);
1423   3                  write_vp_u16(VP_T_SET_INT, tmp);
1424   3              }
1425   2          }
1426   1      
1427   1          tmp = read_vp_u16(VP_GRAPH_EN);
1428   1          if (tmp == 1u || tmp == 2u)
1429   1              g_graph_en = (u8)tmp;
1430   1      }
1431          
1432          /* –ß—Ç–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞ –∏–∑ VP –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É g_graph_cfg[idx] */
1433          static void read_single_graph_from_vp(u8 idx)
1434          {
1435   1          GraphConfig *cfg = &g_graph_cfg[idx];
1436   1          u16 base;
1437   1          u16 v;
1438   1      
1439   1          switch (idx)
1440   1          {
1441   2              case 0: base = VP_G1_STATUS; break;
1442   2              case 1: base = VP_G2_STATUS; break;
1443   2              case 2: base = VP_G3_STATUS; break;
1444   2              case 3: base = VP_G4_STATUS; break;
1445   2              default: return;
1446   2          }
1447   1      
1448   1          v = read_vp_u16(base + 0u);         /* –°—Ç–∞—Ç—É—Å */
1449   1          cfg->status = (v == 2u) ? 2u : 1u;
1450   1      
1451   1          v = read_vp_u16(base + 1u);         /* –î–Ω–∏ (–±–∏—Ç–æ–≤–∞—è –º–∞—Å–∫–∞) */
1452   1          cfg->days = (v <= 127u) ? (u8)v : 0u;
1453   1      
1454   1          v = read_vp_u16(base + 2u);         /* –°–∫–æ—Ä–æ—Å—Ç—å –≥—Ä–∞—Ñ–∏–∫–∞ */
1455   1          if (v >= 1u && v <= 5u) cfg->speed = (u8)v;
1456   1          else                    cfg->speed = 5u;
1457   1      
1458   1          v = read_vp_u16(base + 3u);         /* –¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–∞, 16..32 */
1459   1          if (v >= 16u && v <= 32u) cfg->temp_int = (u8)v;
1460   1          else                      cfg->temp_int = 22u;
1461   1      
1462   1          v = read_vp_u16(base + 4u);         /* –ß–∞—Å—ã –Ω–∞—á–∞–ª–∞ (100..123) */
1463   1          if (v >= 100u && v <= 123u) cfg->shour = (u8)(v - 100u);
1464   1          else                        cfg->shour = 0u;
1465   1      
1466   1          v = read_vp_u16(base + 5u);         /* –ú–∏–Ω—É—Ç—ã –Ω–∞—á–∞–ª–∞ (100..159) */
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 25  

1467   1          if (v >= 100u && v <= 159u) cfg->smin = (u8)(v - 100u);
1468   1          else                        cfg->smin = 0u;
1469   1      
1470   1          v = read_vp_u16(base + 6u);         /* –ß–∞—Å—ã –∫–æ–Ω—Ü–∞ (100..123) */
1471   1          if (v >= 100u && v <= 123u) cfg->ehour = (u8)(v - 100u);
1472   1          else                        cfg->ehour = 0u;
1473   1      
1474   1          v = read_vp_u16(base + 7u);         /* –ú–∏–Ω—É—Ç—ã –∫–æ–Ω—Ü–∞ (100..159) */
1475   1          if (v >= 100u && v <= 159u) cfg->emin = (u8)(v - 100u);
1476   1          else                        cfg->emin = 0u;
1477   1      }
1478          
1479          /* –ß—Ç–µ–Ω–∏–µ –≤—Å–µ—Ö —á–µ—Ç—ã—Ä—ë—Ö –≥—Ä–∞—Ñ–∏–∫–æ–≤ */
1480          static void read_graphs_from_vp(void)
1481          {
1482   1          u8 i;
1483   1          for (i = 0; i < 4; ++i)
1484   1          {
1485   2              read_single_graph_from_vp(i);
1486   2          }
1487   1      }
1488          
1489          /* ---------------------------------------------------------------
1490           * –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
1491           * ------------------------------------------------------------- */
1492          
1493          static void update_valve_with_hysteresis(s16 delta)
1494          {
1495   1          if (g_valve_open)
1496   1          {
1497   2              if (delta < -TEMP_HYST_10X) set_valve(0);
1498   2          }
1499   1          else
1500   1          {
1501   2              if (delta > TEMP_HYST_10X) set_valve(1);
1502   2          }
1503   1      }
1504          
1505          static void apply_auto_speed_and_valve(s16 delta)
1506          {
1507   1          u8 spd;
1508   1          bit vlv;
1509   1      
1510   1          if (g_mode == 2)
1511   1          {
1512   2              if (delta >= 0)        { spd = 1; vlv = 1; }
1513   2              else if (delta >= -20) { spd = 1; vlv = 0; }
1514   2              else if (delta >= -40) { spd = 2; vlv = 0; }
1515   2              else                   { spd = 3; vlv = 0; }
1516   2          }
1517   1          else
1518   1          {
1519   2              if (delta < 0)        { spd = 1; vlv = 0; }
1520   2              else if (delta < 20)  { spd = 1; vlv = 1; }
1521   2              else if (delta < 40)  { spd = 2; vlv = 1; }
1522   2              else                  { spd = 3; vlv = 1; }
1523   2          }
1524   1      
1525   1          set_speed_relays(spd);
1526   1          set_valve(vlv);
1527   1      }
1528          
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 26  

1529          static void apply_main_control(void)
1530          {
1531   1          s16 delta;
1532   1      
1533   1          if (g_onoff == 1)
1534   1          {
1535   2              apply_off_state();
1536   2              return;
1537   2          }
1538   1      
1539   1          delta = (s16)g_t_real_10x - (s16)g_t_set_10x;
1540   1      
1541   1          if (g_speed >= 1 && g_speed <= 3)
1542   1          {
1543   2              set_speed_relays(g_speed);
1544   2              update_valve_with_hysteresis(delta);
1545   2          }
1546   1          else if (g_speed == 4)
1547   1          {
1548   2              apply_auto_speed_and_valve(delta);
1549   2          }
1550   1          else
1551   1          {
1552   2              set_speed_relays(0);
1553   2          }
1554   1      }
1555          
1556          /* ---------------------------------------------------------------
1557           * –ì—Ä–∞—Ñ–∏–∫–∏
1558           * ------------------------------------------------------------- */
1559          
1560          static bit graph_is_today(const GraphConfig* g)
1561          {
1562   1          if (g_rtc.weekday > 6) return 0;
1563   1          return (g->days & (1u << g_rtc.weekday)) ? 1 : 0;
1564   1      }
1565          
1566          static void process_single_graph(u8 idx)
1567          {
1568   1          GraphConfig* cfg = &g_graph_cfg[idx];
1569   1          GraphRuntime* rt = &g_graph_rt[idx];
1570   1      
1571   1          if (g_graph_en != 2 || cfg->status != 2 || !graph_is_today(cfg))
1572   1          {
1573   2              rt->active = 0;
1574   2              return;
1575   2          }
1576   1      
1577   1          if (!rt->active && g_rtc.hour == cfg->shour && g_rtc.min == cfg->smin && g_rtc.sec == 0)
1578   1          {
1579   2              rt->active = 1;
1580   2              rt->prev_speed = g_speed;
1581   2              rt->prev_t_set = g_t_set_10x;
1582   2      
1583   2              if (cfg->speed == 5) g_onoff = 1;
1584   2              else
1585   2              {
1586   3                  g_onoff = 2;
1587   3                  g_speed = cfg->speed;
1588   3                  g_t_set_10x = (u16)cfg->temp_int * 10u;
1589   3              }
1590   2          }
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 27  

1591   1      
1592   1          if (rt->active && g_rtc.hour == cfg->ehour && g_rtc.min == cfg->emin && g_rtc.sec == 0)
1593   1          {
1594   2              u8 i, other = 0;
1595   2              rt->active = 0;
1596   2      
1597   2              for (i = 0; i < 4; ++i)
1598   2                  if (g_graph_rt[i].active) { other = 1; break; }
1599   2      
1600   2              if (!other) g_onoff = 1;
1601   2              else
1602   2              {
1603   3                  g_speed = rt->prev_speed;
1604   3                  g_t_set_10x = rt->prev_t_set;
1605   3              }
1606   2          }
1607   1      }
1608          
1609          static void update_graphs(void)
1610          {
1611   1          u8 i;
1612   1      
1613   1          /* –ö–∞–∂–¥—ã–π —Ä–∞–∑ –ø–æ–¥—Ç—è–≥–∏–≤–∞–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–æ–≤
             - –∏–∑ VP */
1614   1          read_graphs_from_vp();
1615   1      
1616   1          for (i = 0; i < 4; ++i)
1617   1          {
1618   2              process_single_graph(i);
1619   2          }
1620   1      }
1621          
1622          /* ---------------------------------------------------------------
1623           * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
1624           * ------------------------------------------------------------- */
1625          
1626          static void init_state_and_vps(void)
1627          {
1628   1          u8 i;
1629   1          u16 tmp;
1630   1      
1631   1          /* –ß—Ç–µ–Ω–∏–µ Modbus –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏–∑ VP */
1632   1          tmp = read_vp_u16(VP_MB_ADDR);
1633   1          if (tmp >= 1 && tmp <= 247) g_mb_addr = (u8)tmp;
1634   1          else { g_mb_addr = 247; write_vp_u16(VP_MB_ADDR, 247); }
1635   1      
1636   1          tmp = read_vp_u16(VP_MB_SPEED);
1637   1          if (tmp >= 1 && tmp <= 7) g_mb_speed_idx = (u8)tmp;
1638   1          else { g_mb_speed_idx = 7; write_vp_u16(VP_MB_SPEED, 7); }
1639   1      
1640   1          tmp = read_vp_u16(VP_MB_PROTO);
1641   1          if (tmp >= 1 && tmp <= 6) g_mb_proto = (u8)tmp;
1642   1          else { g_mb_proto = 1; write_vp_u16(VP_MB_PROTO, 1); }
1643   1      
1644   1          /* –ß—Ç–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ */
1645   1          tmp = read_vp_u16(VP_ONOFF);
1646   1          if (tmp == 1 || tmp == 2) g_onoff = (u8)tmp;
1647   1          else { g_onoff = 2; write_vp_u16(VP_ONOFF, 2); }
1648   1      
1649   1          tmp = read_vp_u16(VP_SPEED);
1650   1          if (tmp >= 1 && tmp <= 4) g_speed = (u8)tmp;
1651   1          else { g_speed = 1; write_vp_u16(VP_SPEED, 1); }
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 28  

1652   1      
1653   1          tmp = read_vp_u16(VP_MODE);
1654   1          if (tmp == 1 || tmp == 2) g_mode = (u8)tmp;
1655   1          else { g_mode = 2; write_vp_u16(VP_MODE, 2); }
1656   1      
1657   1          tmp = read_vp_u16(VP_T_SET_10X);
1658   1          if (tmp >= 160 && tmp <= 320) g_t_set_10x = tmp;
1659   1          else
1660   1          {
1661   2              g_t_set_10x = 220;
1662   2              write_vp_u16(VP_T_SET_10X, 220);
1663   2              write_vp_u16(VP_T_SET_INT, 22);
1664   2          }
1665   1      
1666   1          tmp = read_vp_u16(VP_GRAPH_EN);
1667   1          if (tmp == 1 || tmp == 2) g_graph_en = (u8)tmp;
1668   1          else { g_graph_en = 1; write_vp_u16(VP_GRAPH_EN, 1); }
1669   1      
1670   1          /* –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã */
1671   1          init_temperature_calibration();
1672   1      
1673   1          /* –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã 
1674   1           * –°—Ç–∞–≤–∏–º 0 —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –∫–æ–≥–¥–∞ –ø–µ—Ä–≤–æ–µ —Ä–µ–∞–ª—å–Ω–æ–µ –∏–∑–º–µ—Ä–µ–Ω–∏–µ 
             -–ø—Ä–æ–∏–∑–æ–π–¥—ë—Ç */
1675   1          g_t_real_10x = 0;
1676   1          Temperature_Real = 0;
1677   1          Temperatrue_Real_Old = 0;
1678   1          temp_filter_init = 0;  /* –°–±—Ä–æ—Å —Ñ–∏–ª—å—Ç—Ä–∞ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ –∏–∑–º–µ—Ä–µ–Ω–∏—è */
1679   1          
1680   1          write_vp_u16(VP_T_REAL_10X, g_t_real_10x);
1681   1          write_vp_u16(VP_T_REAL_INT, g_t_real_10x / 10u);
1682   1      
1683   1          /* –†–∞–Ω—Ç–∞–π–º-—á–∞—Å—Ç—å –≥—Ä–∞—Ñ–∏–∫–æ–≤ (—á—Ç–æ –±—ã–ª–æ –¥–æ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏) */
1684   1          for (i = 0; i < 4; ++i)
1685   1          {
1686   2              g_graph_rt[i].active     = 0;
1687   2              g_graph_rt[i].prev_speed = g_speed;
1688   2              g_graph_rt[i].prev_t_set = g_t_set_10x;
1689   2          }
1690   1      
1691   1          /* –ß–∏—Ç–∞–µ–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–æ–≤ –∏–∑ VP */
1692   1          read_graphs_from_vp();
1693   1      }
1694          
1695          /* ---------------------------------------------------------------
1696           * MAIN
1697           * ------------------------------------------------------------- */
1698          
1699          int main(void)
1700          {
1701   1          init_system();
1702   1          init_relays();
1703   1          init_state_and_vps();
1704   1      
1705   1          /* –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UART5 –¥–ª—è Modbus */
1706   1          uart5_init(g_mb_speed_idx, g_mb_proto);
1707   1      
1708   1          /* –ß—Ç–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ */
1709   1          rtc_read_from_dgus();
1710   1          rtc_publish_to_vp();
1711   1      
1712   1          for (;;)
C51 COMPILER V9.60.7.0   MAIN                                                              12/18/2025 16:00:24 PAGE 29  

1713   1          {
1714   2              /* Modbus –æ–±—Ä–∞–±–æ—Ç–∫–∞ */
1715   2              if (g_mb_frame_ready)
1716   2              {
1717   3                  modbus_process_frame();
1718   3              }
1719   2      
1720   2              /* –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä—ã */
1721   2              update_temperature();
1722   2      
1723   2              /* –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑ –≤ —Å–µ–∫—É–Ω–¥—É */
1724   2              if (g_rtc_1s_flag)
1725   2              {
1726   3                  g_rtc_1s_flag = 0;
1727   3      
1728   3                  rtc_tick_1s();
1729   3                  rtc_publish_to_vp();
1730   3      
1731   3                  read_control_params_from_vp();
1732   3                  update_graphs();
1733   3                  apply_main_control();
1734   3              }
1735   2      
1736   2              delay_ms(5);
1737   2          }
1738   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8332    ----
   CONSTANT SIZE    =    948    ----
   XDATA SIZE       =    309     124
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
